[{"path":"http://klintkanopka.com/meow/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Klint Kanopka Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"writing-your-own-data-loaders","dir":"Articles","previous_headings":"","what":"Writing your own data loaders","title":"Data Loaders","text":"Data loaders encode data generating process (DGP) simulation. provide two basic data loaders, one loads pre-generated parameters responses files, one generates data according 1PL IRT model. Let‚Äôs start loader reads existing data take look core features data loader function needs participate cooperatively meow ecosystem. Interestingly enough, required inputs data loader function, ‚Äôs first thing gets called internal meow simulation. data loader can , theoretically, whatever arguments like exceptions. arguments theta, diff, resp, resp_cur, adj_mat, select_seed used, standard arguments used item selection parameter update functions. Besides , argument names generally fine can passed directly data loader named arguments meow() function. First, let‚Äôs look output. can see ‚Äôs list three named components: resp, theta_tru, diff_tru. resp object dataframe item response data long form. contains three columns, containing numeric data, response matrix aligned data standard Item Response Warehouse. first, id, contains 1-indexed integer respondent id person ii. second, item, contains 1-indexed item identifier item jj. third, resp, contains simulated response person ii item jj, xijx_{ij}. dichotomous responses, use binary response variable, xij‚àà{0,1}x_{ij} \\\\{0,1\\}. Next, theta_tru object. Currently, implemented vector contains true abilities, ith element, Œ∏i\\theta_i, true ability ithi^\\text{th} respondent. near future, re-implemented dataframe easily allow multidimensional models. Finally, come diff_tru object. Currently, implemented vector contains true item difficulties, jth element, bjb_j, true difficulty jthj^\\text{th} item. near future, re-implemented dataframe easily allow IRT models beyond 1PL.","code":"data_existing <- function(   resp_path = 'data/sample-resp.csv',   theta_path = 'data/true-sample-theta.rds',   diff_path = 'data/true-sample-diff.rds' ) {   out <- list(     resp = utils::read.csv(resp_path),     theta_tru = readRDS(theta_path),     diff_tru = readRDS(diff_path)   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"function-arguments","dir":"Articles","previous_headings":"","what":"Function arguments","title":"Data Loaders","text":"Interestingly enough, required inputs data loader function, ‚Äôs first thing gets called internal meow simulation. data loader can , theoretically, whatever arguments like exceptions. arguments theta, diff, resp, resp_cur, adj_mat, select_seed used, standard arguments used item selection parameter update functions. Besides , argument names generally fine can passed directly data loader named arguments meow() function.","code":""},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"return-values","dir":"Articles","previous_headings":"","what":"Return values","title":"Data Loaders","text":"First, let‚Äôs look output. can see ‚Äôs list three named components: resp, theta_tru, diff_tru. resp object dataframe item response data long form. contains three columns, containing numeric data, response matrix aligned data standard Item Response Warehouse. first, id, contains 1-indexed integer respondent id person ii. second, item, contains 1-indexed item identifier item jj. third, resp, contains simulated response person ii item jj, xijx_{ij}. dichotomous responses, use binary response variable, xij‚àà{0,1}x_{ij} \\\\{0,1\\}. Next, theta_tru object. Currently, implemented vector contains true abilities, ith element, Œ∏i\\theta_i, true ability ithi^\\text{th} respondent. near future, re-implemented dataframe easily allow multidimensional models. Finally, come diff_tru object. Currently, implemented vector contains true item difficulties, jth element, bjb_j, true difficulty jthj^\\text{th} item. near future, re-implemented dataframe easily allow IRT models beyond 1PL.","code":""},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"the-resp-object","dir":"Articles","previous_headings":"Writing your own data loaders","what":"The $resp object","title":"Data Loaders","text":"resp object dataframe item response data long form. contains three columns, containing numeric data, response matrix aligned data standard Item Response Warehouse. first, id, contains 1-indexed integer respondent id person ii. second, item, contains 1-indexed item identifier item jj. third, resp, contains simulated response person ii item jj, xijx_{ij}. dichotomous responses, use binary response variable, xij‚àà{0,1}x_{ij} \\\\{0,1\\}.","code":""},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"the-theta_tru-object","dir":"Articles","previous_headings":"Writing your own data loaders","what":"The $theta_tru object","title":"Data Loaders","text":"Next, theta_tru object. Currently, implemented vector contains true abilities, ith element, Œ∏i\\theta_i, true ability ithi^\\text{th} respondent. near future, re-implemented dataframe easily allow multidimensional models.","code":""},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"the-diff_tru-object","dir":"Articles","previous_headings":"Writing your own data loaders","what":"The $diff_tru object","title":"Data Loaders","text":"Finally, come diff_tru object. Currently, implemented vector contains true item difficulties, jth element, bjb_j, true difficulty jthj^\\text{th} item. near future, re-implemented dataframe easily allow IRT models beyond 1PL.","code":""},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"implementing-a-1pl-data-loader","dir":"Articles","previous_headings":"","what":"Implementing a 1PL data loader","title":"Data Loaders","text":"Now let‚Äôs look default 1PL based data loader. code shown : function simulates data according simple inflexible DGP. takes number respondents, N_persons number items, N_items, following: Sets seed according supplied data_seed. Simulates person abilities, Œ∏i\\theta_i, ‚àà{1,...,Npersons}\\\\{1, ..., N_\\text{persons}\\} Œ∏i‚àºùí©(0,1)\\theta_i \\sim \\mathcal{N}(0,1) Simulates item difficulties, bjb_j, j‚àà{1,...,Nitems}j \\\\{1, ..., N_\\text{items}\\} bj‚àºùí©(0,1)b_j \\sim \\mathcal{N}(0,1) Simulates dichotomous item responses, xij‚àà{0,1}x_{ij} \\\\{0,1\\}, according 1PL item response function: P(xij=1|Œ∏i)=11+e‚àí(Œ∏i‚àíbj)P(x_{ij} = 1 | \\theta_i) = \\frac{1}{1+e^{-(\\theta_i - b_j)}} Clears seed calling set.seed(NULL), subsequent analysis determined data seed. Packages items returns inside list.","code":"data_default <- function(N_persons = 100, N_items = 50, data_seed = 242424) {   # note default behavior is fixed seed to ensure data consistency across runs   set.seed(data_seed)    theta_tru <- stats::rnorm(N_persons)   diff_tru <- stats::rnorm(N_items)    theta_mat <- matrix(     theta_tru,     nrow = N_persons,     ncol = N_items,     byrow = FALSE   )   diff_mat <- matrix(diff_tru, nrow = N_persons, ncol = N_items, byrow = TRUE)    p <- stats::plogis(theta_mat - diff_mat)   resp <- matrix(     stats::rbinom(length(p), 1, p),     nrow = N_persons,     ncol = N_items   ) |>     as.data.frame() |>     dplyr::mutate(id = 1:N_persons) |>     tidyr::pivot_longer(       tidyselect::starts_with('V'),       names_to = 'item',       values_to = 'resp',       names_prefix = 'V'     ) |>     dplyr::select(.data$id, .data$item, .data$resp) |>     dplyr::mutate(dplyr::across(tidyselect::everything(), as.numeric))    out <- list(resp = resp, theta_tru = theta_tru, diff_tru = diff_tru)   set.seed(NULL)   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/data-loaders.html","id":"final-important-note-on-setting-random-seeds","dir":"Articles","previous_headings":"","what":"Final important note on setting random seeds","title":"Data Loaders","text":"data loader uses random number generation allow take random seed reproducibility, make sure clear seed end data loader calling set.seed(NULL). don‚Äôt, current version seed persist downstream simulation, full process become deterministic. Specifically, want compare multiple runs item selection /parameter update algorithm uses degree randomization applied dataset, failing clear seed end data loader make impossible.","code":""},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"understanding-item-selection-functions","dir":"Articles","previous_headings":"","what":"Understanding Item Selection Functions","title":"Item Selection Functions","text":"Item selection functions meow take current state simulation return next set responses included analysis. receive information : Current person parameter estimates Current item parameter estimates available response data Currently selected responses Item-item adjacency matrix (exposure control) item selection functions must follow signature: Item selection functions must return dataframe format input resp object - long-form dataframe columns id, item, resp. dataframe contain responses included current iteration simulation.","code":"select_function <- function(   pers,           # Current person parameter estimates   item,           # Current item parameter estimates   resp,           # All available response data   resp_cur = NULL, # Currently selected responses   adj_mat = NULL,  # Item-item adjacency matrix   ...             # Additional arguments ) {   # Function implementation   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"function-signature","dir":"Articles","previous_headings":"","what":"Function Signature","title":"Item Selection Functions","text":"item selection functions must follow signature:","code":"select_function <- function(   pers,           # Current person parameter estimates   item,           # Current item parameter estimates   resp,           # All available response data   resp_cur = NULL, # Currently selected responses   adj_mat = NULL,  # Item-item adjacency matrix   ...             # Additional arguments ) {   # Function implementation   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"return-values","dir":"Articles","previous_headings":"","what":"Return Values","title":"Item Selection Functions","text":"Item selection functions must return dataframe format input resp object - long-form dataframe columns id, item, resp. dataframe contain responses included current iteration simulation.","code":""},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"available-item-selection-functions","dir":"Articles","previous_headings":"","what":"Available Item Selection Functions","title":"Item Selection Functions","text":"select_sequential() function selects items predetermined order: function: 1. first iteration, selects first 5 items respondents 2. subsequent iterations, selects next unadministered item respondent 3. Uses dplyr::anti_join() find responses yet included 4. Uses dplyr::slice_head() select one item per respondent select_random() function selects items randomly: function: 1. Sets random seed reproducibility 2. first iteration, selects first 5 items 3. subsequent iterations, randomly selects one unadministered item per respondent 4. Uses dplyr::slice_sample() random selection 5. Clears seed avoid affecting downstream processes select_max_info() function selects items maximize information current ability estimate: function: 1. first iteration, selects first 5 items 2. subsequent iterations, calculates Fisher information available item respondent‚Äôs current ability estimate 3. Selects item maximum information respondent 4. Uses 2PL information function: (Œ∏)=a2‚ãÖP(Œ∏)‚ãÖ(1‚àíP(Œ∏))(\\theta) = ^2 \\cdot P(\\theta) \\cdot (1 - P(\\theta))","code":"select_sequential <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::slice_head(n = 1, by = .data$id)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) } select_random <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   select_seed = NULL ) {   set.seed(select_seed)   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::slice_sample(n = 1, by = .data$id)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   set.seed(NULL)   return(resp_new) } select_max_info <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::left_join(pers, by = 'id') |>       dplyr::left_join(item, by = 'item') |>       dplyr::mutate(         info = .data$a^2 *           stats::plogis(.data$a * (.data$theta - .data$b)) *           (1 - stats::plogis(.data$a * (.data$theta - .data$b)))       ) |>       dplyr::slice_max(.data$info, n = 1, by = .data$id) |>       dplyr::select(.data$id, .data$item, .data$resp)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"sequential-selection","dir":"Articles","previous_headings":"","what":"Sequential Selection","title":"Item Selection Functions","text":"select_sequential() function selects items predetermined order: function: 1. first iteration, selects first 5 items respondents 2. subsequent iterations, selects next unadministered item respondent 3. Uses dplyr::anti_join() find responses yet included 4. Uses dplyr::slice_head() select one item per respondent","code":"select_sequential <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::slice_head(n = 1, by = .data$id)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"random-selection","dir":"Articles","previous_headings":"","what":"Random Selection","title":"Item Selection Functions","text":"select_random() function selects items randomly: function: 1. Sets random seed reproducibility 2. first iteration, selects first 5 items 3. subsequent iterations, randomly selects one unadministered item per respondent 4. Uses dplyr::slice_sample() random selection 5. Clears seed avoid affecting downstream processes","code":"select_random <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   select_seed = NULL ) {   set.seed(select_seed)   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::slice_sample(n = 1, by = .data$id)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   set.seed(NULL)   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"maximum-information-selection","dir":"Articles","previous_headings":"","what":"Maximum Information Selection","title":"Item Selection Functions","text":"select_max_info() function selects items maximize information current ability estimate: function: 1. first iteration, selects first 5 items 2. subsequent iterations, calculates Fisher information available item respondent‚Äôs current ability estimate 3. Selects item maximum information respondent 4. Uses 2PL information function: (Œ∏)=a2‚ãÖP(Œ∏)‚ãÖ(1‚àíP(Œ∏))(\\theta) = ^2 \\cdot P(\\theta) \\cdot (1 - P(\\theta))","code":"select_max_info <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::left_join(pers, by = 'id') |>       dplyr::left_join(item, by = 'item') |>       dplyr::mutate(         info = .data$a^2 *           stats::plogis(.data$a * (.data$theta - .data$b)) *           (1 - stats::plogis(.data$a * (.data$theta - .data$b)))       ) |>       dplyr::slice_max(.data$info, n = 1, by = .data$id) |>       dplyr::select(.data$id, .data$item, .data$resp)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Item Selection Functions","text":"Handle first iteration: Always check resp_cur NULL return appropriate initial set responses Use anti_join: Always use dplyr::anti_join() find unadministered items Return proper format: Ensure function returns dataframe id, item, resp columns Consider exposure control: Use adj_mat parameter implement exposure control needed Document parameters: Clearly document additional parameters function accepts Test thoroughly: Test function various scenarios using simulations","code":""},{"path":"http://klintkanopka.com/meow/articles/item-selection.html","id":"using-custom-functions","dir":"Articles","previous_headings":"","what":"Using Custom Functions","title":"Item Selection Functions","text":"use custom item selection function simulation:","code":"# Define your custom function my_select_function <- function(pers, item, resp, resp_cur = NULL, adj_mat = NULL, ...) {   # Your implementation here }  # Use it in simulation results <- meow(   select_fun = my_select_function,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(custom_param = 0.5),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"mathematical-foundation","dir":"Articles","previous_headings":"","what":"Mathematical Foundation","title":"Implementing the Maths Garden Update Algorithm","text":"Maths Garden algorithm implements simultaneous updates person abilities (Œ∏\\theta) item difficulties (bb) using gradient-based learning. update equations : Person Ability Update: Œ∏jnew=Œ∏jold+KŒ∏‚àë‚ààIj(Sij‚àíE(Sij))\\theta_j^{new} = \\theta_j^{old} + K_\\theta \\sum_{\\I_j} (S_{ij} - E(S_{ij})) Item Difficulty Update: binew=biold+Kb‚àëj‚ààJi(E(Sij)‚àíSij)b_i^{new} = b_i^{old} + K_b \\sum_{j \\J_i} (E(S_{ij}) - S_{ij}) : - Œ∏j\\theta_j ability person jj - bib_i difficulty item ii - SijS_{ij} observed response (0 1) person jj item ii - E(Sij)E(S_{ij}) expected probability correct response - KŒ∏K_\\theta KbK_b learning rates abilities difficulties respectively - IjI_j set items responded person jj - JiJ_i set persons responded item ii expected probability E(Sij)E(S_{ij}) calculated using logistic function: E(Sij)=P(Sij=1|Œ∏j,bi)=11+e‚àí(Œ∏j‚àíbi)E(S_{ij}) = P(S_{ij} = 1 | \\theta_j, b_i) = \\frac{1}{1 + e^{-(\\theta_j - b_i)}} 1-parameter logistic (1PL) item response model, also known Rasch model. Person Ability Updates: person performs better expected (correct responses predicted), ability estimate increases. perform worse expected, ability estimate decreases. Item Difficulty Updates: item answered correctly often expected, difficulty decreases (becomes easier). ‚Äôs answered correctly less often expected, difficulty increases (becomes harder). Learning Rates: KK parameters control quickly estimates change. Larger values lead faster adaptation may cause instability.","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"core-update-equations","dir":"Articles","previous_headings":"","what":"Core Update Equations","title":"Implementing the Maths Garden Update Algorithm","text":"Maths Garden algorithm implements simultaneous updates person abilities (Œ∏\\theta) item difficulties (bb) using gradient-based learning. update equations : Person Ability Update: Œ∏jnew=Œ∏jold+KŒ∏‚àë‚ààIj(Sij‚àíE(Sij))\\theta_j^{new} = \\theta_j^{old} + K_\\theta \\sum_{\\I_j} (S_{ij} - E(S_{ij})) Item Difficulty Update: binew=biold+Kb‚àëj‚ààJi(E(Sij)‚àíSij)b_i^{new} = b_i^{old} + K_b \\sum_{j \\J_i} (E(S_{ij}) - S_{ij}) : - Œ∏j\\theta_j ability person jj - bib_i difficulty item ii - SijS_{ij} observed response (0 1) person jj item ii - E(Sij)E(S_{ij}) expected probability correct response - KŒ∏K_\\theta KbK_b learning rates abilities difficulties respectively - IjI_j set items responded person jj - JiJ_i set persons responded item ii","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"expected-response-probability","dir":"Articles","previous_headings":"","what":"Expected Response Probability","title":"Implementing the Maths Garden Update Algorithm","text":"expected probability E(Sij)E(S_{ij}) calculated using logistic function: E(Sij)=P(Sij=1|Œ∏j,bi)=11+e‚àí(Œ∏j‚àíbi)E(S_{ij}) = P(S_{ij} = 1 | \\theta_j, b_i) = \\frac{1}{1 + e^{-(\\theta_j - b_i)}} 1-parameter logistic (1PL) item response model, also known Rasch model.","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"intuition-behind-the-updates","dir":"Articles","previous_headings":"","what":"Intuition Behind the Updates","title":"Implementing the Maths Garden Update Algorithm","text":"Person Ability Updates: person performs better expected (correct responses predicted), ability estimate increases. perform worse expected, ability estimate decreases. Item Difficulty Updates: item answered correctly often expected, difficulty decreases (becomes easier). ‚Äôs answered correctly less often expected, difficulty increases (becomes harder). Learning Rates: KK parameters control quickly estimates change. Larger values lead faster adaptation may cause instability.","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"implementation-in-meow","dir":"Articles","previous_headings":"","what":"Implementation in meow","title":"Implementing the Maths Garden Update Algorithm","text":"update_maths_garden() function implements algorithm: calculates expected probability correct response person-item combination using logistic function. person, : - Collects responses person - Calculates sum prediction errors (observed - expected) - Multiplies learning rate - Updates ability estimate item, : - Collects responses item - Calculates sum prediction errors (expected - observed) - Multiplies learning rate - Updates difficulty estimate","code":"update_maths_garden <- function(theta, diff, resp) {   # Calculate expected probabilities using logistic function   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Update theta (ability) for each person   theta_updated <- theta   for (j in unique(resp$id)) {     # Get responses for person j     resp_j <- resp[resp$id == j, ]     # Calculate update term     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Update beta (difficulty) for each item   beta_updated <- diff   for (i in unique(resp$item)) {     # Get responses for item i     resp_i <- resp[resp$item == i, ]     # Calculate update term     update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)     beta_updated[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta_updated,     diff_est = beta_updated,     resp_cur = resp   )   return(out) } E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item]) for (j in unique(resp$id)) {   resp_j <- resp[resp$id == j, ]   update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])   theta_updated[j] <- theta[j] + update_term } for (i in unique(resp$item)) {   resp_i <- resp[resp$item == i, ]   update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)   beta_updated[i] <- diff[i] + update_term }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"function-overview","dir":"Articles","previous_headings":"","what":"Function Overview","title":"Implementing the Maths Garden Update Algorithm","text":"update_maths_garden() function implements algorithm:","code":"update_maths_garden <- function(theta, diff, resp) {   # Calculate expected probabilities using logistic function   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Update theta (ability) for each person   theta_updated <- theta   for (j in unique(resp$id)) {     # Get responses for person j     resp_j <- resp[resp$id == j, ]     # Calculate update term     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Update beta (difficulty) for each item   beta_updated <- diff   for (i in unique(resp$item)) {     # Get responses for item i     resp_i <- resp[resp$item == i, ]     # Calculate update term     update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)     beta_updated[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta_updated,     diff_est = beta_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"step-by-step-breakdown","dir":"Articles","previous_headings":"","what":"Step-by-Step Breakdown","title":"Implementing the Maths Garden Update Algorithm","text":"calculates expected probability correct response person-item combination using logistic function. person, : - Collects responses person - Calculates sum prediction errors (observed - expected) - Multiplies learning rate - Updates ability estimate item, : - Collects responses item - Calculates sum prediction errors (expected - observed) - Multiplies learning rate - Updates difficulty estimate","code":"E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item]) for (j in unique(resp$id)) {   resp_j <- resp[resp$id == j, ]   update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])   theta_updated[j] <- theta[j] + update_term } for (i in unique(resp$item)) {   resp_i <- resp[resp$item == i, ]   update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)   beta_updated[i] <- diff[i] + update_term }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"expected-probability-calculation","dir":"Articles","previous_headings":"Implementation in meow","what":"1. Expected Probability Calculation","title":"Implementing the Maths Garden Update Algorithm","text":"calculates expected probability correct response person-item combination using logistic function.","code":"E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"person-ability-updates","dir":"Articles","previous_headings":"Implementation in meow","what":"2. Person Ability Updates","title":"Implementing the Maths Garden Update Algorithm","text":"person, : - Collects responses person - Calculates sum prediction errors (observed - expected) - Multiplies learning rate - Updates ability estimate","code":"for (j in unique(resp$id)) {   resp_j <- resp[resp$id == j, ]   update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])   theta_updated[j] <- theta[j] + update_term }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"item-difficulty-updates","dir":"Articles","previous_headings":"Implementation in meow","what":"3. Item Difficulty Updates","title":"Implementing the Maths Garden Update Algorithm","text":"item, : - Collects responses item - Calculates sum prediction errors (expected - observed) - Multiplies learning rate - Updates difficulty estimate","code":"for (i in unique(resp$item)) {   resp_i <- resp[resp$item == i, ]   update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)   beta_updated[i] <- diff[i] + update_term }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"using-the-maths-garden-algorithm","dir":"Articles","previous_headings":"","what":"Using the Maths Garden Algorithm","title":"Implementing the Maths Garden Update Algorithm","text":"can modify learning rates creating wrapper function:","code":"# Run simulation with Maths Garden updates results <- meow(   select_fun = select_max_info,   update_fun = update_maths_garden,   data_loader = data_simple_1pl,   data_args = list(N_persons = 100, N_items = 50) ) update_maths_garden_custom <- function(theta, diff, resp, K_theta = 0.05, K_beta = 0.05) {   # Calculate expected probabilities using logistic function   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   theta_updated <- theta   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Update beta (difficulty) for each item   beta_updated <- diff   for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)     beta_updated[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta_updated,     diff_est = beta_updated,     resp_cur = resp   )   return(out) }  # Use with custom learning rates results <- meow(   select_fun = select_max_info,   update_fun = update_maths_garden_custom,   data_loader = data_simple_1pl,   update_args = list(K_theta = 0.05, K_beta = 0.05),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Implementing the Maths Garden Update Algorithm","text":"","code":"# Run simulation with Maths Garden updates results <- meow(   select_fun = select_max_info,   update_fun = update_maths_garden,   data_loader = data_simple_1pl,   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"customizing-learning-rates","dir":"Articles","previous_headings":"","what":"Customizing Learning Rates","title":"Implementing the Maths Garden Update Algorithm","text":"can modify learning rates creating wrapper function:","code":"update_maths_garden_custom <- function(theta, diff, resp, K_theta = 0.05, K_beta = 0.05) {   # Calculate expected probabilities using logistic function   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   theta_updated <- theta   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Update beta (difficulty) for each item   beta_updated <- diff   for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)     beta_updated[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta_updated,     diff_est = beta_updated,     resp_cur = resp   )   return(out) }  # Use with custom learning rates results <- meow(   select_fun = select_max_info,   update_fun = update_maths_garden_custom,   data_loader = data_simple_1pl,   update_args = list(K_theta = 0.05, K_beta = 0.05),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"advantages-and-limitations","dir":"Articles","previous_headings":"","what":"Advantages and Limitations","title":"Implementing the Maths Garden Update Algorithm","text":"Simplicity: algorithm straightforward implement understand Real-time Updates: person item parameters updated simultaneously Iteration Required: Updates computed directly without iterative optimization Computational Efficiency: Fast computation suitable real-time applications Interpretable: update rules clear intuitive meaning Fixed Learning Rates: algorithm uses constant learning rates don‚Äôt adapt data Uncertainty Quantification: Doesn‚Äôt provide confidence intervals standard errors Potential Instability: Large learning rates can cause parameter estimates oscillate Assumes 1PL Model: Based Rasch model, may fit data requiring 2PL 3PL models Prior Information: Doesn‚Äôt incorporate prior knowledge parameters","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"advantages","dir":"Articles","previous_headings":"","what":"Advantages","title":"Implementing the Maths Garden Update Algorithm","text":"Simplicity: algorithm straightforward implement understand Real-time Updates: person item parameters updated simultaneously Iteration Required: Updates computed directly without iterative optimization Computational Efficiency: Fast computation suitable real-time applications Interpretable: update rules clear intuitive meaning","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Implementing the Maths Garden Update Algorithm","text":"Fixed Learning Rates: algorithm uses constant learning rates don‚Äôt adapt data Uncertainty Quantification: Doesn‚Äôt provide confidence intervals standard errors Potential Instability: Large learning rates can cause parameter estimates oscillate Assumes 1PL Model: Based Rasch model, may fit data requiring 2PL 3PL models Prior Information: Doesn‚Äôt incorporate prior knowledge parameters","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"extensions-and-modifications","dir":"Articles","previous_headings":"","what":"Extensions and Modifications","title":"Implementing the Maths Garden Update Algorithm","text":"can implement adaptive learning rates change based amount data: can add constraints prevent extreme parameter values:","code":"update_maths_garden_adaptive <- function(theta, diff, resp) {   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Adaptive learning rates based on number of responses   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     n_responses <- nrow(resp_j)          # Decrease learning rate with more responses     K_theta_adaptive <- 0.1 / (1 + n_responses * 0.1)          update_term <- K_theta_adaptive * sum(resp_j$resp - E_Sij[resp$id == j])     theta[j] <- theta[j] + update_term   }    for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     n_responses <- nrow(resp_i)          # Decrease learning rate with more responses     K_beta_adaptive <- 0.1 / (1 + n_responses * 0.1)          update_term <- K_beta_adaptive * sum(E_Sij[resp$item == i] - resp_i$resp)     diff[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta,     diff_est = diff,     resp_cur = resp   )   return(out) } update_maths_garden_constrained <- function(theta, diff, resp,                                            theta_bounds = c(-4, 4),                                            diff_bounds = c(-4, 4)) {   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta with constraints   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- 0.1 * sum(resp_j$resp - E_Sij[resp$id == j])     theta[j] <- theta[j] + update_term          # Apply constraints     theta[j] <- max(theta_bounds[1], min(theta_bounds[2], theta[j]))   }    # Update diff with constraints   for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     update_term <- 0.1 * sum(E_Sij[resp$item == i] - resp_i$resp)     diff[i] <- diff[i] + update_term          # Apply constraints     diff[i] <- max(diff_bounds[1], min(diff_bounds[2], diff[i]))   }    out <- list(     theta_est = theta,     diff_est = diff,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"adaptive-learning-rates","dir":"Articles","previous_headings":"","what":"Adaptive Learning Rates","title":"Implementing the Maths Garden Update Algorithm","text":"can implement adaptive learning rates change based amount data:","code":"update_maths_garden_adaptive <- function(theta, diff, resp) {   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Adaptive learning rates based on number of responses   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     n_responses <- nrow(resp_j)          # Decrease learning rate with more responses     K_theta_adaptive <- 0.1 / (1 + n_responses * 0.1)          update_term <- K_theta_adaptive * sum(resp_j$resp - E_Sij[resp$id == j])     theta[j] <- theta[j] + update_term   }    for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     n_responses <- nrow(resp_i)          # Decrease learning rate with more responses     K_beta_adaptive <- 0.1 / (1 + n_responses * 0.1)          update_term <- K_beta_adaptive * sum(E_Sij[resp$item == i] - resp_i$resp)     diff[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta,     diff_est = diff,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"constrained-updates","dir":"Articles","previous_headings":"","what":"Constrained Updates","title":"Implementing the Maths Garden Update Algorithm","text":"can add constraints prevent extreme parameter values:","code":"update_maths_garden_constrained <- function(theta, diff, resp,                                            theta_bounds = c(-4, 4),                                            diff_bounds = c(-4, 4)) {   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta with constraints   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- 0.1 * sum(resp_j$resp - E_Sij[resp$id == j])     theta[j] <- theta[j] + update_term          # Apply constraints     theta[j] <- max(theta_bounds[1], min(theta_bounds[2], theta[j]))   }    # Update diff with constraints   for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     update_term <- 0.1 * sum(E_Sij[resp$item == i] - resp_i$resp)     diff[i] <- diff[i] + update_term          # Apply constraints     diff[i] <- max(diff_bounds[1], min(diff_bounds[2], diff[i]))   }    out <- list(     theta_est = theta,     diff_est = diff,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Implementing the Maths Garden Update Algorithm","text":"Start Small Learning Rates: Begin KŒ∏=Kb=0.1K_\\theta = K_b = 0.1 adjust based results Monitor Convergence: Check parameter estimates stabilize iterations Use Constraints: Implement bounds parameter values prevent extreme estimates Consider Adaptive Rates: Use decreasing learning rates stable long-term estimates Validate Results: Compare estimation methods possible Test Different Data: Ensure algorithm works well specific data characteristics","code":""},{"path":"http://klintkanopka.com/meow/articles/maths-garden-update.html","id":"example-complete-workflow","dir":"Articles","previous_headings":"","what":"Example: Complete Workflow","title":"Implementing the Maths Garden Update Algorithm","text":"","code":"# Load required packages library(meow)  # Define custom Maths Garden function with adaptive rates update_maths_garden_improved <- function(theta, diff, resp) {   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Adaptive learning rates   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     n_responses <- nrow(resp_j)     K_theta_adaptive <- 0.1 / (1 + n_responses * 0.05)          update_term <- K_theta_adaptive * sum(resp_j$resp - E_Sij[resp$id == j])     theta[j] <- theta[j] + update_term     theta[j] <- max(-4, min(4, theta[j]))  # Constraints   }    for (i in unique(resp$item)) {     resp_i <- resp[resp$item == i, ]     n_responses <- nrow(resp_i)     K_beta_adaptive <- 0.1 / (1 + n_responses * 0.05)          update_term <- K_beta_adaptive * sum(E_Sij[resp$item == i] - resp_i$resp)     diff[i] <- diff[i] + update_term     diff[i] <- max(-4, min(4, diff[i]))  # Constraints   }    out <- list(     theta_est = theta,     diff_est = diff,     resp_cur = resp   )   return(out) }  # Run simulation results <- meow(   select_fun = select_max_info,   update_fun = update_maths_garden_improved,   data_loader = data_simple_1pl,   data_args = list(N_persons = 100, N_items = 50, data_seed = 123) )  # Analyze results print(head(results$results))"},{"path":"http://klintkanopka.com/meow/articles/meow-viz.html","id":"no-exposure-controls","dir":"Articles","previous_headings":"","what":"No Exposure Controls","title":"Visualizing with meow: Comparing Item Exposure Control Methods","text":"simulation exposure controls, ‚Äôll use built-item selection method, select_max_info(). conduct sample simulation using data generated 1PL MLE based updates Œ∏ÃÇ\\hat{\\theta}, can run: Let‚Äôs look common ways might want visualize results simulations. One thing note, last line out_info$results going final bias values parameter simulation, ‚Äôll focus examining evolution time. First, ‚Äôll extract just results dataframe. Since ‚Äôll combining exposure control method later, ‚Äôll also label : Next want extract bias person abilities. can also grab current estimates like. Just change suffix select _bias _est.  Figure 1 useful comparing across methods, though. Now let‚Äôs take look individual parameter trajectories evolve time. , ‚Äôll track bias.  Figure 2","code":"out_none <- meow(   select_fun = select_max_info,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   init = NULL,   fix = 'item' ) results_none <- out_none$results |>   mutate(control = 'None') results_none |>   select(iter, control, starts_with('pers_')) |>   select(iter, control, ends_with('_bias')) |>   pivot_longer(ends_with('_bias'), names_to = 'person', values_to = 'bias') |>   group_by(iter, control) |>   summarize(rmse = sqrt(sum(bias^2)), .groups = 'drop') |>   ggplot(aes(x = iter, y = rmse, color = control)) +   geom_line() +   labs(     x = 'Number of Items Delivered',     y = 'RMSE for Person Ability',     color = 'Exposure Controls'   ) +   theme_minimal() +   theme(legend.position = 'bottom') results_none |>   select(iter, control, starts_with('pers_')) |>   select(iter, control, ends_with('_bias')) |>   pivot_longer(ends_with('_bias'), names_to = 'person', values_to = 'bias') |>   ggplot(aes(x = iter, y = bias, color = control, group=person)) +   geom_line(alpha=0.4) +   labs(     x = 'Number of Items Delivered',     y = 'Bias in Estimated Person Ability',     color = 'Exposure Controls'   ) +   theme_minimal() +   theme(legend.position = 'bottom')"},{"path":"http://klintkanopka.com/meow/articles/meow-viz.html","id":"root-mean-squared-error-rmse-of-person-abilities","dir":"Articles","previous_headings":"","what":"Root Mean Squared Error (RMSE) of Person Abilities","title":"Visualizing with meow: Comparing Item Exposure Control Methods","text":"First, ‚Äôll extract just results dataframe. Since ‚Äôll combining exposure control method later, ‚Äôll also label : Next want extract bias person abilities. can also grab current estimates like. Just change suffix select _bias _est.  Figure 1 useful comparing across methods, though. Now let‚Äôs take look individual parameter trajectories evolve time. , ‚Äôll track bias.  Figure 2","code":"results_none <- out_none$results |>   mutate(control = 'None') results_none |>   select(iter, control, starts_with('pers_')) |>   select(iter, control, ends_with('_bias')) |>   pivot_longer(ends_with('_bias'), names_to = 'person', values_to = 'bias') |>   group_by(iter, control) |>   summarize(rmse = sqrt(sum(bias^2)), .groups = 'drop') |>   ggplot(aes(x = iter, y = rmse, color = control)) +   geom_line() +   labs(     x = 'Number of Items Delivered',     y = 'RMSE for Person Ability',     color = 'Exposure Controls'   ) +   theme_minimal() +   theme(legend.position = 'bottom') results_none |>   select(iter, control, starts_with('pers_')) |>   select(iter, control, ends_with('_bias')) |>   pivot_longer(ends_with('_bias'), names_to = 'person', values_to = 'bias') |>   ggplot(aes(x = iter, y = bias, color = control, group=person)) +   geom_line(alpha=0.4) +   labs(     x = 'Number of Items Delivered',     y = 'Bias in Estimated Person Ability',     color = 'Exposure Controls'   ) +   theme_minimal() +   theme(legend.position = 'bottom')"},{"path":"http://klintkanopka.com/meow/articles/meow-viz.html","id":"restricting-item-exposure","dir":"Articles","previous_headings":"","what":"Restricting Item Exposure","title":"Visualizing with meow: Comparing Item Exposure Control Methods","text":"quite similar unrestricted case, just involves two additional steps additional parameter needs get passed selection function. First need compute exposure rates administered items, second, need drop potential items current exposure rate. diagonal adjacency matrix exposure counts, quickly compute exposure rates filter potential solutions based upon . pass exposure rate item selection function ‚Äôs different default value, can conduct simulation looks like : Now let‚Äôs say want compare RMSE estimated abilities time two methods. can bind together rows two outputs (making sure ‚Äôve labeled control method) plot :  Figure 3 can see , turns , restricting item exposure doesn‚Äôt hurt RMSE much. individual parameter trajectories? ‚Äôll separate two using faceting. ‚Äôll also look trajectories first twenty items.  Figure 4 Early , trajectories identical exposure controls haven‚Äôt yet kicked . didn‚Äôt see much difference RMSE plot, continue see much difference.","code":"select_rest <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   r_max = 0.025 ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     r_obs <- data.frame(       item = item$item,        r_obs = diag(adj_mat)/sum(diag(adj_mat)), row.names=NULL     )      resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     ) |>       dplyr::left_join(pers, by = 'id') |>       dplyr::left_join(item, by = 'item') |>       dplyr::left_join(r_obs, by='item') |>       dplyr::filter(r_obs < r_max) |>       dplyr::mutate(         info = .data$a^2 *           stats::plogis(.data$a * (.data$theta - .data$b)) *           (1 - stats::plogis(.data$a * (.data$theta - .data$b)))       ) |>       dplyr::slice_max(.data$info, n = 1, by = .data$id) |>       dplyr::select(.data$id, .data$item, .data$resp)     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) } out_rest <- meow(   select_fun = select_rest,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   init = NULL,   fix = 'item',   select_args = list(r_max = 0.02) ) results_rest <- out_rest$results |>   mutate(control = 'Restricted')  results <- bind_rows(   results_none,   results_rest )  results |>   select(iter, control, starts_with('pers_')) |>   select(iter, control, ends_with('_bias')) |>   pivot_longer(ends_with('_bias'), names_to = 'person', values_to = 'bias') |>   group_by(iter, control) |>   summarize(rmse = sqrt(sum(bias^2)), .groups = 'drop') |>   ggplot(aes(x = iter, y = rmse, color = control)) +   geom_line() +   labs(     x = 'Number of Items Delivered',     y = 'RMSE for Person Ability',     color = 'Exposure Controls'   ) +   theme_minimal() +   theme(legend.position = 'bottom') results |>   select(iter, control, starts_with('pers_')) |>   select(iter, control, ends_with('_bias')) |>   pivot_longer(ends_with('_bias'), names_to = 'person', values_to = 'bias') |>   filter(iter <= 20) |>   ggplot(aes(x = iter, y = bias, color = control, group=person)) +   geom_line(alpha=0.4) +   labs(     x = 'Number of Items Delivered',     y = 'Bias in Estimated Person Ability',     color = 'Exposure Controls'   ) +   facet_grid(control ~ .) +   theme_minimal() +   theme(legend.position = 'bottom')"},{"path":"http://klintkanopka.com/meow/articles/meow-viz.html","id":"visualizing-the-adjacency-matrix","dir":"Articles","previous_headings":"","what":"Visualizing the Adjacency Matrix","title":"Visualizing with meow: Comparing Item Exposure Control Methods","text":"One thing can also create interactive visualizations evolution adjacency matrix. really helpful getting sense exposure controls selection algorithms might impacting item utilization. ‚Äôll need two packages , statnet creating network objects ndtv creating dynamic visuals. first thing ‚Äôll need create network list. calling network() function statnet onto object adjacency matrix list. output meow formatted make easy single lapply(): Next collapse single dynamic network object. call networkDynamic(). , output structured make just visualizing simple possible. Finally, render movie. open browser window interactive movie. can click specific nodes get information follow time, move forward backward time, also zoom . ‚Äôve also added information item difficulty. Items difficulties zero (easier) colored blue, harder items colored red. Additionally, size nodes larger farther zero. makes quick identify easiest hardest items largest nodes. good thing click hardest item (largest red node) see gets connected time.","code":"library(statnet) library(ndtv) info_nets <- lapply(out_info$adj_mats, network) dyn_info <- networkDynamic(network.list = info_nets) render.d3movie(   dyn_info,   usearrows = FALSE,   main = 'Maximum Fisher Information Item Selection',   vertex.cex = abs(out_info$item$b),   vertex.col = ifelse(out_info$item$b < 0, 'dodgerblue', 'tomato') )"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"mathematical-foundation","dir":"Articles","previous_headings":"","what":"Mathematical Foundation","title":"Network-Based Item Selection","text":"algorithm represents item pool weighted graph : Nodes: Individual items pool Edges: Connections items, weighted co-response patterns Edge Weight: Reflects frequently two items answered together respondents algorithm uses Floyd-Warshall algorithm compute shortest paths item pairs: Edge Weight Matrix: WijW_{ij} represents weight items ii jj Distance Matrix: DijD_{ij} represents shortest path distance item ii item jj Item Selection: person, select items maximum distance answered items choice edge weight function significantly impacts algorithm‚Äôs behavior. several approaches: Logic: Higher co-responses = lower weights = shorter distances - Items frequently answered together considered ‚Äúcloser‚Äù - Encourages selection items rarely answered together - alpha parameter prevents division zero Logic: Similar inverse logarithmic scaling - Reduces impact high co-response counts - gradual transition different co-response levels Logic: Higher co-responses = higher weights = longer distances - Inverts original logic: items frequently answered together considered ‚Äúfarther apart‚Äù - might intuitive applications - Encourages selection items frequently answered together (exposure control) Logic: Flexible transformation parameter control - beta < 1: Reduces impact high co-response counts - beta > 1: Amplifies impact high co-response counts - beta = 1: Linear relationship Logic: Exponential decay weights - Higher co-responses lead much lower weights - sensitive small changes co-response counts - lambda controls rate decay","code":"edge_weight_inverse <- function(adj_mat, alpha = 1) {   return(1 / (adj_mat + alpha)) } edge_weight_negative_log <- function(adj_mat, alpha = 1) {   return(-log(adj_mat + alpha)) } edge_weight_linear <- function(adj_mat, max_co_responses = NULL) {   if (is.null(max_co_responses)) {     max_co_responses <- max(adj_mat)   }   return(adj_mat / max_co_responses) } edge_weight_power <- function(adj_mat, beta = 0.5, alpha = 1) {   return((adj_mat + alpha)^beta) } edge_weight_exponential <- function(adj_mat, lambda = 0.1, alpha = 1) {   return(exp(-lambda * (adj_mat + alpha))) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"network-representation","dir":"Articles","previous_headings":"","what":"Network Representation","title":"Network-Based Item Selection","text":"algorithm represents item pool weighted graph : Nodes: Individual items pool Edges: Connections items, weighted co-response patterns Edge Weight: Reflects frequently two items answered together respondents","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"distance-calculation","dir":"Articles","previous_headings":"","what":"Distance Calculation","title":"Network-Based Item Selection","text":"algorithm uses Floyd-Warshall algorithm compute shortest paths item pairs: Edge Weight Matrix: WijW_{ij} represents weight items ii jj Distance Matrix: DijD_{ij} represents shortest path distance item ii item jj Item Selection: person, select items maximum distance answered items","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"edge-weight-strategies","dir":"Articles","previous_headings":"","what":"Edge Weight Strategies","title":"Network-Based Item Selection","text":"choice edge weight function significantly impacts algorithm‚Äôs behavior. several approaches: Logic: Higher co-responses = lower weights = shorter distances - Items frequently answered together considered ‚Äúcloser‚Äù - Encourages selection items rarely answered together - alpha parameter prevents division zero Logic: Similar inverse logarithmic scaling - Reduces impact high co-response counts - gradual transition different co-response levels Logic: Higher co-responses = higher weights = longer distances - Inverts original logic: items frequently answered together considered ‚Äúfarther apart‚Äù - might intuitive applications - Encourages selection items frequently answered together (exposure control) Logic: Flexible transformation parameter control - beta < 1: Reduces impact high co-response counts - beta > 1: Amplifies impact high co-response counts - beta = 1: Linear relationship Logic: Exponential decay weights - Higher co-responses lead much lower weights - sensitive small changes co-response counts - lambda controls rate decay","code":"edge_weight_inverse <- function(adj_mat, alpha = 1) {   return(1 / (adj_mat + alpha)) } edge_weight_negative_log <- function(adj_mat, alpha = 1) {   return(-log(adj_mat + alpha)) } edge_weight_linear <- function(adj_mat, max_co_responses = NULL) {   if (is.null(max_co_responses)) {     max_co_responses <- max(adj_mat)   }   return(adj_mat / max_co_responses) } edge_weight_power <- function(adj_mat, beta = 0.5, alpha = 1) {   return((adj_mat + alpha)^beta) } edge_weight_exponential <- function(adj_mat, lambda = 0.1, alpha = 1) {   return(exp(-lambda * (adj_mat + alpha))) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"inverse-weight-original","dir":"Articles","previous_headings":"Mathematical Foundation","what":"1. Inverse Weight (Original)","title":"Network-Based Item Selection","text":"Logic: Higher co-responses = lower weights = shorter distances - Items frequently answered together considered ‚Äúcloser‚Äù - Encourages selection items rarely answered together - alpha parameter prevents division zero","code":"edge_weight_inverse <- function(adj_mat, alpha = 1) {   return(1 / (adj_mat + alpha)) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"negative-log-weight","dir":"Articles","previous_headings":"Mathematical Foundation","what":"2. Negative Log Weight","title":"Network-Based Item Selection","text":"Logic: Similar inverse logarithmic scaling - Reduces impact high co-response counts - gradual transition different co-response levels","code":"edge_weight_negative_log <- function(adj_mat, alpha = 1) {   return(-log(adj_mat + alpha)) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"linear-weight-inverted-logic","dir":"Articles","previous_headings":"Mathematical Foundation","what":"3. Linear Weight (Inverted Logic)","title":"Network-Based Item Selection","text":"Logic: Higher co-responses = higher weights = longer distances - Inverts original logic: items frequently answered together considered ‚Äúfarther apart‚Äù - might intuitive applications - Encourages selection items frequently answered together (exposure control)","code":"edge_weight_linear <- function(adj_mat, max_co_responses = NULL) {   if (is.null(max_co_responses)) {     max_co_responses <- max(adj_mat)   }   return(adj_mat / max_co_responses) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"power-weight","dir":"Articles","previous_headings":"Mathematical Foundation","what":"4. Power Weight","title":"Network-Based Item Selection","text":"Logic: Flexible transformation parameter control - beta < 1: Reduces impact high co-response counts - beta > 1: Amplifies impact high co-response counts - beta = 1: Linear relationship","code":"edge_weight_power <- function(adj_mat, beta = 0.5, alpha = 1) {   return((adj_mat + alpha)^beta) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"exponential-weight","dir":"Articles","previous_headings":"Mathematical Foundation","what":"5. Exponential Weight","title":"Network-Based Item Selection","text":"Logic: Exponential decay weights - Higher co-responses lead much lower weights - sensitive small changes co-response counts - lambda controls rate decay","code":"edge_weight_exponential <- function(adj_mat, lambda = 0.1, alpha = 1) {   return(exp(-lambda * (adj_mat + alpha))) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"algorithm-implementation","dir":"Articles","previous_headings":"","what":"Algorithm Implementation","title":"Network-Based Item Selection","text":"select_max_dist function implements strategy: select_max_dist_enhanced function allows specify different edge weight strategies:","code":"select_max_dist <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   n_candidates = 1 ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     # Calculate distance matrix using inverse edge weights     dist_mat <- Rfast::floyd(1 / adj_mat)      # Get each person's answered items     local_items <- resp_cur |>       dplyr::select(.data$id, .data$item) |>       dplyr::group_by(.data$id) |>       dplyr::mutate(seq = 1:dplyr::n()) |>       dplyr::ungroup() |>       tidyr::pivot_wider(         id_cols = .data$id,         names_from = .data$seq,         names_prefix = 'item_',         values_from = .data$item       ) |>       dplyr::arrange(.data$id) |>       dplyr::select(-.data$id) |>       as.matrix()      # Calculate distance from answered items to each candidate     get_distance <- function(id, item, dist_mat, local_items) {       dist <- min(dist_mat[local_items[id, ], item])       return(dist)     }      # Select items with maximum distance     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     )      if (nrow(resp_new) > 0) {       resp_new <- resp_new |>         dplyr::rowwise() |>         dplyr::mutate(           distance = get_distance(.data$id, .data$item, dist_mat, local_items)         ) |>         dplyr::ungroup() |>         dplyr::slice_max(.data$distance, n = n_candidates, by = .data$id) |>         dplyr::left_join(pers, by = 'id') |>         dplyr::left_join(item, by = 'item') |>         dplyr::mutate(           info = .data$a^2 *             stats::plogis(.data$a * (.data$theta - .data$b)) *             (1 - stats::plogis(.data$a * (.data$theta - .data$b)))         ) |>         dplyr::slice_max(.data$info, n = 1, by = .data$id) |>         dplyr::select(.data$id, .data$item, .data$resp)     }     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) } select_max_dist_enhanced <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   n_candidates = 1,   edge_weight_fun = edge_weight_inverse,   edge_weight_args = list() ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     # Calculate edge weights using the specified function     edge_weights <- do.call(edge_weight_fun,                             c(list(adj_mat = adj_mat), edge_weight_args))          # Compute distance matrix using Floyd-Warshall     dist_mat <- Rfast::floyd(edge_weights)          # Rest of the algorithm remains the same...   }   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"core-algorithm","dir":"Articles","previous_headings":"","what":"Core Algorithm","title":"Network-Based Item Selection","text":"select_max_dist function implements strategy:","code":"select_max_dist <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   n_candidates = 1 ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     # Calculate distance matrix using inverse edge weights     dist_mat <- Rfast::floyd(1 / adj_mat)      # Get each person's answered items     local_items <- resp_cur |>       dplyr::select(.data$id, .data$item) |>       dplyr::group_by(.data$id) |>       dplyr::mutate(seq = 1:dplyr::n()) |>       dplyr::ungroup() |>       tidyr::pivot_wider(         id_cols = .data$id,         names_from = .data$seq,         names_prefix = 'item_',         values_from = .data$item       ) |>       dplyr::arrange(.data$id) |>       dplyr::select(-.data$id) |>       as.matrix()      # Calculate distance from answered items to each candidate     get_distance <- function(id, item, dist_mat, local_items) {       dist <- min(dist_mat[local_items[id, ], item])       return(dist)     }      # Select items with maximum distance     resp_new <- dplyr::anti_join(       resp,       resp_cur,       by = c('id', 'item', 'resp')     )      if (nrow(resp_new) > 0) {       resp_new <- resp_new |>         dplyr::rowwise() |>         dplyr::mutate(           distance = get_distance(.data$id, .data$item, dist_mat, local_items)         ) |>         dplyr::ungroup() |>         dplyr::slice_max(.data$distance, n = n_candidates, by = .data$id) |>         dplyr::left_join(pers, by = 'id') |>         dplyr::left_join(item, by = 'item') |>         dplyr::mutate(           info = .data$a^2 *             stats::plogis(.data$a * (.data$theta - .data$b)) *             (1 - stats::plogis(.data$a * (.data$theta - .data$b)))         ) |>         dplyr::slice_max(.data$info, n = 1, by = .data$id) |>         dplyr::select(.data$id, .data$item, .data$resp)     }     resp_new <- dplyr::bind_rows(resp_cur, resp_new)   }   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"enhanced-version-with-configurable-edge-weights","dir":"Articles","previous_headings":"","what":"Enhanced Version with Configurable Edge Weights","title":"Network-Based Item Selection","text":"select_max_dist_enhanced function allows specify different edge weight strategies:","code":"select_max_dist_enhanced <- function(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   n_candidates = 1,   edge_weight_fun = edge_weight_inverse,   edge_weight_args = list() ) {   if (is.null(resp_cur)) {     return(resp[resp$item <= 5, ])   } else {     # Calculate edge weights using the specified function     edge_weights <- do.call(edge_weight_fun,                             c(list(adj_mat = adj_mat), edge_weight_args))          # Compute distance matrix using Floyd-Warshall     dist_mat <- Rfast::floyd(edge_weights)          # Rest of the algorithm remains the same...   }   return(resp_new) }"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"using-different-edge-weight-strategies","dir":"Articles","previous_headings":"","what":"Using Different Edge Weight Strategies","title":"Network-Based Item Selection","text":"","code":"# Use the original inverse weight approach results <- meow(   select_fun = select_max_dist,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(n_candidates = 3),   data_args = list(N_persons = 100, N_items = 50) ) # Use linear weights where higher co-responses = higher weights results <- meow(   select_fun = select_max_dist_enhanced,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(     n_candidates = 3,     edge_weight_fun = edge_weight_linear   ),   data_args = list(N_persons = 100, N_items = 50) ) # Use power transformation with beta = 0.3 results <- meow(   select_fun = select_max_dist_enhanced,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(     n_candidates = 3,     edge_weight_fun = edge_weight_power,     edge_weight_args = list(beta = 0.3, alpha = 1)   ),   data_args = list(N_persons = 100, N_items = 50) ) # Use exponential decay with lambda = 0.05 results <- meow(   select_fun = select_max_dist_enhanced,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(     n_candidates = 3,     edge_weight_fun = edge_weight_exponential,     edge_weight_args = list(lambda = 0.05, alpha = 1)   ),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"example-1-original-inverse-weight","dir":"Articles","previous_headings":"","what":"Example 1: Original Inverse Weight","title":"Network-Based Item Selection","text":"","code":"# Use the original inverse weight approach results <- meow(   select_fun = select_max_dist,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(n_candidates = 3),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"example-2-linear-weight-inverted-logic","dir":"Articles","previous_headings":"","what":"Example 2: Linear Weight (Inverted Logic)","title":"Network-Based Item Selection","text":"","code":"# Use linear weights where higher co-responses = higher weights results <- meow(   select_fun = select_max_dist_enhanced,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(     n_candidates = 3,     edge_weight_fun = edge_weight_linear   ),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"example-3-power-weight-with-custom-parameters","dir":"Articles","previous_headings":"","what":"Example 3: Power Weight with Custom Parameters","title":"Network-Based Item Selection","text":"","code":"# Use power transformation with beta = 0.3 results <- meow(   select_fun = select_max_dist_enhanced,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(     n_candidates = 3,     edge_weight_fun = edge_weight_power,     edge_weight_args = list(beta = 0.3, alpha = 1)   ),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"example-4-exponential-weight","dir":"Articles","previous_headings":"","what":"Example 4: Exponential Weight","title":"Network-Based Item Selection","text":"","code":"# Use exponential decay with lambda = 0.05 results <- meow(   select_fun = select_max_dist_enhanced,   update_fun = update_theta_mle,   data_loader = data_simple_1pl,   select_args = list(     n_candidates = 3,     edge_weight_fun = edge_weight_exponential,     edge_weight_args = list(lambda = 0.05, alpha = 1)   ),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"choosing-the-right-edge-weight-strategy","dir":"Articles","previous_headings":"","what":"Choosing the Right Edge Weight Strategy","title":"Network-Based Item Selection","text":"Goal: Minimize exposure items rarely answered together Use Case: want spread item exposure across different item types Advantage: Simple intuitive Disadvantage: May lead -exposure certain item clusters Goal: Encourage selection items frequently answered together Use Case: want maintain item clusters topic areas Advantage: predictable exposure patterns Disadvantage: May reduce measurement efficiency Goal: Fine-tune sensitivity co-response patterns Use Case: need balance exposure control measurement efficiency Advantage: Flexible parameter control Disadvantage: Requires tuning beta parameter Goal: strong exposure control Use Case: want avoid clustering item exposure Advantage: Strongest exposure control Disadvantage: May significantly reduce measurement efficiency","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"when-to-use-inverse-weight-original","dir":"Articles","previous_headings":"","what":"When to Use Inverse Weight (Original)","title":"Network-Based Item Selection","text":"Goal: Minimize exposure items rarely answered together Use Case: want spread item exposure across different item types Advantage: Simple intuitive Disadvantage: May lead -exposure certain item clusters","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"when-to-use-linear-weight-inverted","dir":"Articles","previous_headings":"","what":"When to Use Linear Weight (Inverted)","title":"Network-Based Item Selection","text":"Goal: Encourage selection items frequently answered together Use Case: want maintain item clusters topic areas Advantage: predictable exposure patterns Disadvantage: May reduce measurement efficiency","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"when-to-use-power-weight","dir":"Articles","previous_headings":"","what":"When to Use Power Weight","title":"Network-Based Item Selection","text":"Goal: Fine-tune sensitivity co-response patterns Use Case: need balance exposure control measurement efficiency Advantage: Flexible parameter control Disadvantage: Requires tuning beta parameter","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"when-to-use-exponential-weight","dir":"Articles","previous_headings":"","what":"When to Use Exponential Weight","title":"Network-Based Item Selection","text":"Goal: strong exposure control Use Case: want avoid clustering item exposure Advantage: Strongest exposure control Disadvantage: May significantly reduce measurement efficiency","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"advantages-of-network-based-selection","dir":"Articles","previous_headings":"","what":"Advantages of Network-Based Selection","title":"Network-Based Item Selection","text":"Whole History Consideration: Considers previously answered items, just last one Flexible Pool Size: n_candidates parameter allows balancing exposure control vs.¬†efficiency Tie-Breaking: Uses maximum information break ties among equally distant items Configurable: Different edge weight strategies allow fine-tuning behavior Theoretically Sound: Based well-established graph theory algorithms","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"limitations-and-considerations","dir":"Articles","previous_headings":"","what":"Limitations and Considerations","title":"Network-Based Item Selection","text":"Computational Cost: Floyd-Warshall algorithm O(n3)O(n^3) nn number items Edge Weight Choice: choice edge weight function significantly impacts results Parameter Tuning: Requires careful tuning edge weight parameters Interpretation: ‚Äúdistance‚Äù concept may always align intuitive notions item similarity","code":""},{"path":"http://klintkanopka.com/meow/articles/network-item-selection.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Network-Based Item Selection","text":"Start Inverse Weight: Use original approach baseline Experiment Parameters: Try different n_candidates values (1-5) Consider Goals: Choose edge weight strategy based whether prioritize exposure control measurement efficiency Monitor Results: Track exposure patterns measurement accuracy Compare Approaches: Test simpler methods like select_max_info","code":""},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"understanding-parameter-update-functions","dir":"Articles","previous_headings":"","what":"Understanding Parameter Update Functions","title":"Parameter Update Functions","text":"Parameter update functions meow receive current state estimated parameters response data, return updated estimates. responsible : Updating person ability estimates (Œ∏\\theta) Updating item difficulty estimates (bb) Updating item discrimination estimates (aa) using 2PL 3PL models Returning updated response set parameter update functions must follow signature: Parameter update functions must return list three components: pers_est: Updated person parameter estimates (dataframe id column parameter columns) item_est: Updated item parameter estimates (dataframe item column parameter columns) resp_cur: response data used estimation (typically input resp)","code":"update_function <- function(   pers,           # Current person parameter estimates   item,           # Current item parameter estimates   resp,           # Response data to use for estimation   ...             # Additional arguments ) {   # Function implementation      out <- list(     pers_est = updated_pers,     item_est = updated_item,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"function-signature","dir":"Articles","previous_headings":"","what":"Function Signature","title":"Parameter Update Functions","text":"parameter update functions must follow signature:","code":"update_function <- function(   pers,           # Current person parameter estimates   item,           # Current item parameter estimates   resp,           # Response data to use for estimation   ...             # Additional arguments ) {   # Function implementation      out <- list(     pers_est = updated_pers,     item_est = updated_item,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"return-values","dir":"Articles","previous_headings":"","what":"Return Values","title":"Parameter Update Functions","text":"Parameter update functions must return list three components: pers_est: Updated person parameter estimates (dataframe id column parameter columns) item_est: Updated item parameter estimates (dataframe item column parameter columns) resp_cur: response data used estimation (typically input resp)","code":""},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"available-parameter-update-functions","dir":"Articles","previous_headings":"","what":"Available Parameter Update Functions","title":"Parameter Update Functions","text":"update_theta_mle() function updates person abilities using maximum likelihood estimation treating item parameters fixed: function: 1. Defines log-likelihood function 2PL model 2. Uses stats::optim() L-BFGS-B method maximize likelihood 3. Constrains ability estimates range [-4, 4] 4. updates person abilities, leaving item parameters unchanged 5. Returns updated person estimates unchanged item estimates update_maths_garden() function implements update rule Maths Garden paper: function implements simple gradient-based update rule: 1. Calculates expected response probabilities using logistic function 2. Updates person abilities: Œ∏jnew=Œ∏j+KŒ∏‚àë(Sij‚àíE(Sij))\\theta_j^{new} = \\theta_j + K_\\theta \\sum_i (S_{ij} - E(S_{ij})) 3. Updates item difficulties: binew=bi+Kb‚àëj(E(Sij)‚àíSij)b_i^{new} = b_i + K_b \\sum_j (E(S_{ij}) - S_{ij}) 4. Uses fixed learning rates can tuned update_prowise_learn() function implements Prowise Learn algorithm paired item updates: function: 1. Updates person abilities using rule Maths Garden 2. Implements paired item updates prevent rating drift 3. person multiple responses, updates pairs consecutive items 4. Uses update rule: Œ∫=0.5‚ãÖ(Kb‚ãÖ(Snow‚àíEnow)‚àíKb‚ãÖ(Sprev‚àíEprev))\\kappa = 0.5 \\cdot (K_b \\cdot (S_{now} - E_{now}) - K_b \\cdot (S_{prev} - E_{prev})) 5. Applies Œ∫\\kappa current item ‚àíŒ∫-\\kappa previous item","code":"update_theta_mle <- function(pers, item, resp) {   # Unidimensional 2PL MLE estimation of ability, treating item params as fixed   theta_mle <- function(pers, item, resp) {     loglik <- function(theta, item, resp) {       p <- stats::plogis(         item$a[resp$item] * (theta[resp$id] - item$b[resp$item])       )       ll <- sum(resp$resp * log(p) + (1 - resp$resp) * log(1 - p))       return(ll)     }      est <- stats::optim(       pers$theta,       loglik,       lower = -4,       upper = 4,       item = item,       resp = resp,       method = 'L-BFGS-B',       control = list(fnscale = -1)     )      return(est$par)   }    pers$theta <- theta_mle(pers, item, resp)    out <- list(     pers_est = pers,     item_est = item,     resp_cur = resp   )   return(out) } update_maths_garden <- function(theta, diff, resp) {   # Implement the update rule from the maths garden paper   # Theta_hat_j = theta_j + K_j (S_ij - E(S_ij))   # Beta_hat_i = beta_i + K_i(E(S_ij)-S_ij)   # where S_ij is the observed score and E(S_ij) is the expected probability    # Calculate expected probabilities using logistic function   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Update theta (ability) for each person   theta_updated <- theta   for (j in unique(resp$id)) {     # Get responses for person j     resp_j <- resp[resp$id == j, ]     # Calculate update term     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Update beta (difficulty) for each item   beta_updated <- diff   for (i in unique(resp$item)) {     # Get responses for item i     resp_i <- resp[resp$item == i, ]     # Calculate update term     update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)     beta_updated[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta_updated,     diff_est = beta_updated,     resp_cur = resp   )   return(out) } update_prowise_learn <- function(theta, diff, resp) {   # Implement the update rule from the Prowise Learn paper with paired item updates   # to prevent rating drift    # Initialize updated parameters   theta_updated <- theta   diff_updated <- diff    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Calculate expected probabilities for all responses   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }   cat(\"Prowise item updates triggered:\", update_count, \"\\n\")    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"maximum-likelihood-estimation-mle","dir":"Articles","previous_headings":"","what":"Maximum Likelihood Estimation (MLE)","title":"Parameter Update Functions","text":"update_theta_mle() function updates person abilities using maximum likelihood estimation treating item parameters fixed: function: 1. Defines log-likelihood function 2PL model 2. Uses stats::optim() L-BFGS-B method maximize likelihood 3. Constrains ability estimates range [-4, 4] 4. updates person abilities, leaving item parameters unchanged 5. Returns updated person estimates unchanged item estimates","code":"update_theta_mle <- function(pers, item, resp) {   # Unidimensional 2PL MLE estimation of ability, treating item params as fixed   theta_mle <- function(pers, item, resp) {     loglik <- function(theta, item, resp) {       p <- stats::plogis(         item$a[resp$item] * (theta[resp$id] - item$b[resp$item])       )       ll <- sum(resp$resp * log(p) + (1 - resp$resp) * log(1 - p))       return(ll)     }      est <- stats::optim(       pers$theta,       loglik,       lower = -4,       upper = 4,       item = item,       resp = resp,       method = 'L-BFGS-B',       control = list(fnscale = -1)     )      return(est$par)   }    pers$theta <- theta_mle(pers, item, resp)    out <- list(     pers_est = pers,     item_est = item,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"maths-garden-update","dir":"Articles","previous_headings":"","what":"Maths Garden Update","title":"Parameter Update Functions","text":"update_maths_garden() function implements update rule Maths Garden paper: function implements simple gradient-based update rule: 1. Calculates expected response probabilities using logistic function 2. Updates person abilities: Œ∏jnew=Œ∏j+KŒ∏‚àë(Sij‚àíE(Sij))\\theta_j^{new} = \\theta_j + K_\\theta \\sum_i (S_{ij} - E(S_{ij})) 3. Updates item difficulties: binew=bi+Kb‚àëj(E(Sij)‚àíSij)b_i^{new} = b_i + K_b \\sum_j (E(S_{ij}) - S_{ij}) 4. Uses fixed learning rates can tuned","code":"update_maths_garden <- function(theta, diff, resp) {   # Implement the update rule from the maths garden paper   # Theta_hat_j = theta_j + K_j (S_ij - E(S_ij))   # Beta_hat_i = beta_i + K_i(E(S_ij)-S_ij)   # where S_ij is the observed score and E(S_ij) is the expected probability    # Calculate expected probabilities using logistic function   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Update theta (ability) for each person   theta_updated <- theta   for (j in unique(resp$id)) {     # Get responses for person j     resp_j <- resp[resp$id == j, ]     # Calculate update term     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Update beta (difficulty) for each item   beta_updated <- diff   for (i in unique(resp$item)) {     # Get responses for item i     resp_i <- resp[resp$item == i, ]     # Calculate update term     update_term <- K_beta * sum(E_Sij[resp$item == i] - resp_i$resp)     beta_updated[i] <- diff[i] + update_term   }    out <- list(     theta_est = theta_updated,     diff_est = beta_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"prowise-learn-update","dir":"Articles","previous_headings":"","what":"Prowise Learn Update","title":"Parameter Update Functions","text":"update_prowise_learn() function implements Prowise Learn algorithm paired item updates: function: 1. Updates person abilities using rule Maths Garden 2. Implements paired item updates prevent rating drift 3. person multiple responses, updates pairs consecutive items 4. Uses update rule: Œ∫=0.5‚ãÖ(Kb‚ãÖ(Snow‚àíEnow)‚àíKb‚ãÖ(Sprev‚àíEprev))\\kappa = 0.5 \\cdot (K_b \\cdot (S_{now} - E_{now}) - K_b \\cdot (S_{prev} - E_{prev})) 5. Applies Œ∫\\kappa current item ‚àíŒ∫-\\kappa previous item","code":"update_prowise_learn <- function(theta, diff, resp) {   # Implement the update rule from the Prowise Learn paper with paired item updates   # to prevent rating drift    # Initialize updated parameters   theta_updated <- theta   diff_updated <- diff    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Calculate expected probabilities for all responses   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }   cat(\"Prowise item updates triggered:\", update_count, \"\\n\")    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Parameter Update Functions","text":"Return proper format: Always return list pers_est, item_est, resp_cur Handle edge cases: Consider happens responses extreme parameter values Parameter constraints: Implement reasonable bounds parameter estimates (e.g., [-4, 4] abilities) Numerical stability: Use log-space calculations appropriate avoid numerical underflow Convergence: Consider implementing convergence checks iterative methods Documentation: Clearly document mathematical basis assumptions algorithm Testing: Test function various scenarios using simulations","code":""},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"using-custom-functions","dir":"Articles","previous_headings":"","what":"Using Custom Functions","title":"Parameter Update Functions","text":"use custom parameter update function simulation:","code":"# Define your custom function my_update_function <- function(pers, item, resp, ...) {   # Your implementation here   out <- list(     pers_est = updated_pers,     item_est = updated_item,     resp_cur = resp   )   return(out) }  # Use it in simulation results <- meow(   select_fun = select_max_info,   update_fun = my_update_function,   data_loader = data_simple_1pl,   update_args = list(custom_param = 0.5),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"mathematical-background","dir":"Articles","previous_headings":"","what":"Mathematical Background","title":"Parameter Update Functions","text":"2PL model, likelihood function : L(Œ∏)=‚àè=1nP(xi|Œ∏)xi(1‚àíP(xi|Œ∏))1‚àíxiL(\\theta) = \\prod_{=1}^{n} P(x_i|\\theta)^{x_i} (1-P(x_i|\\theta))^{1-x_i} P(xi|Œ∏)=11+e‚àíai(Œ∏‚àíbi)P(x_i|\\theta) = \\frac{1}{1 + e^{-a_i(\\theta - b_i)}} log-likelihood : ‚Ñì(Œ∏)=‚àë=1n[xilog(Pi)+(1‚àíxi)log(1‚àíPi)]\\ell(\\theta) = \\sum_{=1}^{n} [x_i \\log(P_i) + (1-x_i)\\log(1-P_i)] gradient-based methods like Maths Garden, update rule : Œ∏new=Œ∏old+Œ∑‚àë(xi‚àíPi)\\theta^{new} = \\theta^{old} + \\eta \\sum_i (x_i - P_i) Œ∑\\eta learning rate PiP_i expected probability correct response.","code":""},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"maximum-likelihood-estimation","dir":"Articles","previous_headings":"","what":"Maximum Likelihood Estimation","title":"Parameter Update Functions","text":"2PL model, likelihood function : L(Œ∏)=‚àè=1nP(xi|Œ∏)xi(1‚àíP(xi|Œ∏))1‚àíxiL(\\theta) = \\prod_{=1}^{n} P(x_i|\\theta)^{x_i} (1-P(x_i|\\theta))^{1-x_i} P(xi|Œ∏)=11+e‚àíai(Œ∏‚àíbi)P(x_i|\\theta) = \\frac{1}{1 + e^{-a_i(\\theta - b_i)}} log-likelihood : ‚Ñì(Œ∏)=‚àë=1n[xilog(Pi)+(1‚àíxi)log(1‚àíPi)]\\ell(\\theta) = \\sum_{=1}^{n} [x_i \\log(P_i) + (1-x_i)\\log(1-P_i)]","code":""},{"path":"http://klintkanopka.com/meow/articles/parameter-update.html","id":"gradient-based-updates","dir":"Articles","previous_headings":"","what":"Gradient-Based Updates","title":"Parameter Update Functions","text":"gradient-based methods like Maths Garden, update rule : Œ∏new=Œ∏old+Œ∑‚àë(xi‚àíPi)\\theta^{new} = \\theta^{old} + \\eta \\sum_i (x_i - P_i) Œ∑\\eta learning rate PiP_i expected probability correct response.","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"mathematical-foundation","dir":"Articles","previous_headings":"","what":"Mathematical Foundation","title":"Implementing the Prowise Learn Update Algorithm","text":"Prowise Learn algorithm builds upon Maths Garden approach adds crucial innovation: paired item updates prevent rating drift. update equations : Person Ability Update: Œ∏jnew=Œ∏jold+KŒ∏‚àë‚ààIj(Sij‚àíE(Sij))\\theta_j^{new} = \\theta_j^{old} + K_\\theta \\sum_{\\I_j} (S_{ij} - E(S_{ij})) Paired Item Difficulty Updates: consecutive responses person, difficulty updates paired: Œ∫=0.5‚ãÖ(Kb‚ãÖ(Snow‚àíEnow)‚àíKb‚ãÖ(Sprev‚àíEprev))\\kappa = 0.5 \\cdot (K_b \\cdot (S_{now} - E_{now}) - K_b \\cdot (S_{prev} - E_{prev}))bnownew=bnowold+Œ∫b_{now}^{new} = b_{now}^{old} + \\kappabprevnew=bprevold‚àíŒ∫b_{prev}^{new} = b_{prev}^{old} - \\kappa : - Œ∏j\\theta_j ability person jj - bib_i difficulty item ii - SijS_{ij} observed response (0 1) person jj item ii - E(Sij)E(S_{ij}) expected probability correct response - KŒ∏K_\\theta KbK_b learning rates abilities difficulties respectively - SnowS_{now} SprevS_{prev} current previous responses - EnowE_{now} EprevE_{prev} expected probabilities current previous items expected probability E(Sij)E(S_{ij}) calculated using logistic function: E(Sij)=P(Sij=1|Œ∏j,bi)=11+e‚àí(Œ∏j‚àíbi)E(S_{ij}) = P(S_{ij} = 1 | \\theta_j, b_i) = \\frac{1}{1 + e^{-(\\theta_j - b_i)}} uses 1-parameter logistic (1PL) item response model. Rating drift occurs item difficulty estimates systematically increase decrease time, often due : Sequential Bias: Later items sequence may systematically easier harder Person Ability Changes: person abilities change testing, item difficulties may incorrectly adjusted Selection Bias: Adaptive selection may create correlations item difficulties administration order paired update mechanism addresses rating drift : Balancing Updates: updating pair items, total difficulty change sums zero Relative Positioning: Items maintain relative difficulty positions Drift Prevention: Systematic increases decreases difficulty prevented","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"core-update-equations","dir":"Articles","previous_headings":"","what":"Core Update Equations","title":"Implementing the Prowise Learn Update Algorithm","text":"Prowise Learn algorithm builds upon Maths Garden approach adds crucial innovation: paired item updates prevent rating drift. update equations : Person Ability Update: Œ∏jnew=Œ∏jold+KŒ∏‚àë‚ààIj(Sij‚àíE(Sij))\\theta_j^{new} = \\theta_j^{old} + K_\\theta \\sum_{\\I_j} (S_{ij} - E(S_{ij})) Paired Item Difficulty Updates: consecutive responses person, difficulty updates paired: Œ∫=0.5‚ãÖ(Kb‚ãÖ(Snow‚àíEnow)‚àíKb‚ãÖ(Sprev‚àíEprev))\\kappa = 0.5 \\cdot (K_b \\cdot (S_{now} - E_{now}) - K_b \\cdot (S_{prev} - E_{prev}))bnownew=bnowold+Œ∫b_{now}^{new} = b_{now}^{old} + \\kappabprevnew=bprevold‚àíŒ∫b_{prev}^{new} = b_{prev}^{old} - \\kappa : - Œ∏j\\theta_j ability person jj - bib_i difficulty item ii - SijS_{ij} observed response (0 1) person jj item ii - E(Sij)E(S_{ij}) expected probability correct response - KŒ∏K_\\theta KbK_b learning rates abilities difficulties respectively - SnowS_{now} SprevS_{prev} current previous responses - EnowE_{now} EprevE_{prev} expected probabilities current previous items","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"expected-response-probability","dir":"Articles","previous_headings":"","what":"Expected Response Probability","title":"Implementing the Prowise Learn Update Algorithm","text":"expected probability E(Sij)E(S_{ij}) calculated using logistic function: E(Sij)=P(Sij=1|Œ∏j,bi)=11+e‚àí(Œ∏j‚àíbi)E(S_{ij}) = P(S_{ij} = 1 | \\theta_j, b_i) = \\frac{1}{1 + e^{-(\\theta_j - b_i)}} uses 1-parameter logistic (1PL) item response model.","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"rating-drift-problem","dir":"Articles","previous_headings":"","what":"Rating Drift Problem","title":"Implementing the Prowise Learn Update Algorithm","text":"Rating drift occurs item difficulty estimates systematically increase decrease time, often due : Sequential Bias: Later items sequence may systematically easier harder Person Ability Changes: person abilities change testing, item difficulties may incorrectly adjusted Selection Bias: Adaptive selection may create correlations item difficulties administration order","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"paired-update-solution","dir":"Articles","previous_headings":"","what":"Paired Update Solution","title":"Implementing the Prowise Learn Update Algorithm","text":"paired update mechanism addresses rating drift : Balancing Updates: updating pair items, total difficulty change sums zero Relative Positioning: Items maintain relative difficulty positions Drift Prevention: Systematic increases decreases difficulty prevented","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"implementation-in-meow","dir":"Articles","previous_headings":"","what":"Implementation in meow","title":"Implementing the Prowise Learn Update Algorithm","text":"update_prowise_learn() function implements algorithm: follows approach Maths Garden person ability updates. implements paired update mechanism: 1. person multiple responses, consider consecutive pairs 2. Calculate update term Œ∫\\kappa based current previous responses 3. Apply +Œ∫+\\kappa current item ‚àíŒ∫-\\kappa previous item 4. ensures total difficulty change pair zero","code":"update_prowise_learn <- function(theta, diff, resp) {   # Initialize updated parameters   theta_updated <- theta   diff_updated <- diff    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Calculate expected probabilities for all responses   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }   cat(\"Prowise item updates triggered:\", update_count, \"\\n\")    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) } for (j in unique(resp$id)) {   resp_j <- resp[resp$id == j, ]   update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])   theta_updated[j] <- theta[j] + update_term } for (person in unique(resp$id)) {   person_idx <- which(resp$id == person)   if (length(person_idx) >= 2) {     for (i in 2:length(person_idx)) {       idx_now <- person_idx[i]       idx_prev <- person_idx[i - 1]       item_now <- resp$item[idx_now]       item_prev <- resp$item[idx_prev]       s_now <- resp$resp[idx_now]       s_prev <- resp$resp[idx_prev]       e_now <- E_Sij[idx_now]       e_prev <- E_Sij[idx_prev]       kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))       diff_updated[item_now] <- diff_updated[item_now] + kappa       diff_updated[item_prev] <- diff_updated[item_prev] - kappa     }   } }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"function-overview","dir":"Articles","previous_headings":"","what":"Function Overview","title":"Implementing the Prowise Learn Update Algorithm","text":"update_prowise_learn() function implements algorithm:","code":"update_prowise_learn <- function(theta, diff, resp) {   # Initialize updated parameters   theta_updated <- theta   diff_updated <- diff    # Learning rates (K values) - these could be tuned   K_theta <- 0.1 # Learning rate for ability   K_beta <- 0.1  # Learning rate for difficulty    # Calculate expected probabilities for all responses   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }   cat(\"Prowise item updates triggered:\", update_count, \"\\n\")    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"step-by-step-breakdown","dir":"Articles","previous_headings":"","what":"Step-by-Step Breakdown","title":"Implementing the Prowise Learn Update Algorithm","text":"follows approach Maths Garden person ability updates. implements paired update mechanism: 1. person multiple responses, consider consecutive pairs 2. Calculate update term Œ∫\\kappa based current previous responses 3. Apply +Œ∫+\\kappa current item ‚àíŒ∫-\\kappa previous item 4. ensures total difficulty change pair zero","code":"for (j in unique(resp$id)) {   resp_j <- resp[resp$id == j, ]   update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])   theta_updated[j] <- theta[j] + update_term } for (person in unique(resp$id)) {   person_idx <- which(resp$id == person)   if (length(person_idx) >= 2) {     for (i in 2:length(person_idx)) {       idx_now <- person_idx[i]       idx_prev <- person_idx[i - 1]       item_now <- resp$item[idx_now]       item_prev <- resp$item[idx_prev]       s_now <- resp$resp[idx_now]       s_prev <- resp$resp[idx_prev]       e_now <- E_Sij[idx_now]       e_prev <- E_Sij[idx_prev]       kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))       diff_updated[item_now] <- diff_updated[item_now] + kappa       diff_updated[item_prev] <- diff_updated[item_prev] - kappa     }   } }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"person-ability-updates","dir":"Articles","previous_headings":"Implementation in meow","what":"1. Person Ability Updates","title":"Implementing the Prowise Learn Update Algorithm","text":"follows approach Maths Garden person ability updates.","code":"for (j in unique(resp$id)) {   resp_j <- resp[resp$id == j, ]   update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])   theta_updated[j] <- theta[j] + update_term }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"paired-item-updates","dir":"Articles","previous_headings":"Implementation in meow","what":"2. Paired Item Updates","title":"Implementing the Prowise Learn Update Algorithm","text":"implements paired update mechanism: 1. person multiple responses, consider consecutive pairs 2. Calculate update term Œ∫\\kappa based current previous responses 3. Apply +Œ∫+\\kappa current item ‚àíŒ∫-\\kappa previous item 4. ensures total difficulty change pair zero","code":"for (person in unique(resp$id)) {   person_idx <- which(resp$id == person)   if (length(person_idx) >= 2) {     for (i in 2:length(person_idx)) {       idx_now <- person_idx[i]       idx_prev <- person_idx[i - 1]       item_now <- resp$item[idx_now]       item_prev <- resp$item[idx_prev]       s_now <- resp$resp[idx_now]       s_prev <- resp$resp[idx_prev]       e_now <- E_Sij[idx_now]       e_prev <- E_Sij[idx_prev]       kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))       diff_updated[item_now] <- diff_updated[item_now] + kappa       diff_updated[item_prev] <- diff_updated[item_prev] - kappa     }   } }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"using-the-prowise-learn-algorithm","dir":"Articles","previous_headings":"","what":"Using the Prowise Learn Algorithm","title":"Implementing the Prowise Learn Update Algorithm","text":"can modify learning rates creating wrapper function:","code":"# Run simulation with Prowise Learn updates results <- meow(   select_fun = select_max_info,   update_fun = update_prowise_learn,   data_loader = data_simple_1pl,   data_args = list(N_persons = 100, N_items = 50) ) update_prowise_learn_custom <- function(theta, diff, resp, K_theta = 0.05, K_beta = 0.05) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates with custom learning rate   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }  # Use with custom learning rates results <- meow(   select_fun = select_max_info,   update_fun = update_prowise_learn_custom,   data_loader = data_simple_1pl,   update_args = list(K_theta = 0.05, K_beta = 0.05),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Implementing the Prowise Learn Update Algorithm","text":"","code":"# Run simulation with Prowise Learn updates results <- meow(   select_fun = select_max_info,   update_fun = update_prowise_learn,   data_loader = data_simple_1pl,   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"customizing-learning-rates","dir":"Articles","previous_headings":"","what":"Customizing Learning Rates","title":"Implementing the Prowise Learn Update Algorithm","text":"can modify learning rates creating wrapper function:","code":"update_prowise_learn_custom <- function(theta, diff, resp, K_theta = 0.05, K_beta = 0.05) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta (ability) for each person   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- K_theta * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates with custom learning rate   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta * (s_now - e_now) - K_beta * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }  # Use with custom learning rates results <- meow(   select_fun = select_max_info,   update_fun = update_prowise_learn_custom,   data_loader = data_simple_1pl,   update_args = list(K_theta = 0.05, K_beta = 0.05),   data_args = list(N_persons = 100, N_items = 50) )"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"advantages-and-limitations","dir":"Articles","previous_headings":"","what":"Advantages and Limitations","title":"Implementing the Prowise Learn Update Algorithm","text":"Prevents Rating Drift: paired update mechanism prevents systematic changes item difficulties Maintains Relative Positions: Items maintain relative difficulty ordering Real-time Updates: person item parameters updated simultaneously Computational Efficiency: Fast computation suitable real-time applications Interpretable: paired update mechanism clear intuitive meaning Requires Multiple Responses: Paired updates work person multiple responses Order Dependency: effectiveness depends order item administration Fixed Learning Rates: Uses constant learning rates don‚Äôt adapt data Uncertainty Quantification: Doesn‚Äôt provide confidence intervals standard errors Assumes 1PL Model: Based Rasch model, may fit data requiring 2PL 3PL models","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"advantages","dir":"Articles","previous_headings":"","what":"Advantages","title":"Implementing the Prowise Learn Update Algorithm","text":"Prevents Rating Drift: paired update mechanism prevents systematic changes item difficulties Maintains Relative Positions: Items maintain relative difficulty ordering Real-time Updates: person item parameters updated simultaneously Computational Efficiency: Fast computation suitable real-time applications Interpretable: paired update mechanism clear intuitive meaning","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Implementing the Prowise Learn Update Algorithm","text":"Requires Multiple Responses: Paired updates work person multiple responses Order Dependency: effectiveness depends order item administration Fixed Learning Rates: Uses constant learning rates don‚Äôt adapt data Uncertainty Quantification: Doesn‚Äôt provide confidence intervals standard errors Assumes 1PL Model: Based Rasch model, may fit data requiring 2PL 3PL models","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"extensions-and-modifications","dir":"Articles","previous_headings":"","what":"Extensions and Modifications","title":"Implementing the Prowise Learn Update Algorithm","text":"can implement adaptive learning rates change based amount data: can add constraints prevent extreme parameter values:","code":"update_prowise_learn_adaptive <- function(theta, diff, resp) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Adaptive learning rates based on number of responses   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     n_responses <- nrow(resp_j)          # Decrease learning rate with more responses     K_theta_adaptive <- 0.1 / (1 + n_responses * 0.1)          update_term <- K_theta_adaptive * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates with adaptive rates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         resp_person <- resp[resp$id == person, ]         n_responses <- nrow(resp_person)         K_beta_adaptive <- 0.1 / (1 + n_responses * 0.1)                  idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta_adaptive * (s_now - e_now) - K_beta_adaptive * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) } update_prowise_learn_constrained <- function(theta, diff, resp,                                             theta_bounds = c(-4, 4),                                             diff_bounds = c(-4, 4)) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta with constraints   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- 0.1 * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term          # Apply constraints     theta_updated[j] <- max(theta_bounds[1], min(theta_bounds[2], theta_updated[j]))   }    # Paired item updates with constraints   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (0.1 * (s_now - e_now) - 0.1 * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa                  # Apply constraints         diff_updated[item_now] <- max(diff_bounds[1], min(diff_bounds[2], diff_updated[item_now]))         diff_updated[item_prev] <- max(diff_bounds[1], min(diff_bounds[2], diff_updated[item_prev]))                  update_count <- update_count + 1       }     }   }    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"adaptive-learning-rates","dir":"Articles","previous_headings":"","what":"Adaptive Learning Rates","title":"Implementing the Prowise Learn Update Algorithm","text":"can implement adaptive learning rates change based amount data:","code":"update_prowise_learn_adaptive <- function(theta, diff, resp) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Adaptive learning rates based on number of responses   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     n_responses <- nrow(resp_j)          # Decrease learning rate with more responses     K_theta_adaptive <- 0.1 / (1 + n_responses * 0.1)          update_term <- K_theta_adaptive * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term   }    # Paired item updates with adaptive rates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         resp_person <- resp[resp$id == person, ]         n_responses <- nrow(resp_person)         K_beta_adaptive <- 0.1 / (1 + n_responses * 0.1)                  idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta_adaptive * (s_now - e_now) - K_beta_adaptive * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa         update_count <- update_count + 1       }     }   }    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"constrained-updates","dir":"Articles","previous_headings":"","what":"Constrained Updates","title":"Implementing the Prowise Learn Update Algorithm","text":"can add constraints prevent extreme parameter values:","code":"update_prowise_learn_constrained <- function(theta, diff, resp,                                             theta_bounds = c(-4, 4),                                             diff_bounds = c(-4, 4)) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Update theta with constraints   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     update_term <- 0.1 * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term          # Apply constraints     theta_updated[j] <- max(theta_bounds[1], min(theta_bounds[2], theta_updated[j]))   }    # Paired item updates with constraints   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (0.1 * (s_now - e_now) - 0.1 * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa                  # Apply constraints         diff_updated[item_now] <- max(diff_bounds[1], min(diff_bounds[2], diff_updated[item_now]))         diff_updated[item_prev] <- max(diff_bounds[1], min(diff_bounds[2], diff_updated[item_prev]))                  update_count <- update_count + 1       }     }   }    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }"},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Implementing the Prowise Learn Update Algorithm","text":"Monitor Update Counts: Pay attention number paired updates triggered Use Appropriate Learning Rates: Start small learning rates (0.05-0.1) adjust Consider Response Order: effectiveness depends sequence responses Validate Stability: Check item difficulties remain stable time Compare Alternatives: Test methods ensure effectiveness Handle Edge Cases: Consider happens responses single responses per person","code":""},{"path":"http://klintkanopka.com/meow/articles/prowise-learn-update.html","id":"example-complete-workflow","dir":"Articles","previous_headings":"","what":"Example: Complete Workflow","title":"Implementing the Prowise Learn Update Algorithm","text":"","code":"# Load required packages library(meow)  # Define improved Prowise Learn function update_prowise_learn_improved <- function(theta, diff, resp) {   theta_updated <- theta   diff_updated <- diff    # Calculate expected probabilities   E_Sij <- stats::plogis(theta[resp$id] - diff[resp$item])    # Adaptive learning rates for person abilities   for (j in unique(resp$id)) {     resp_j <- resp[resp$id == j, ]     n_responses <- nrow(resp_j)     K_theta_adaptive <- 0.1 / (1 + n_responses * 0.05)          update_term <- K_theta_adaptive * sum(resp_j$resp - E_Sij[resp$id == j])     theta_updated[j] <- theta[j] + update_term     theta_updated[j] <- max(-4, min(4, theta_updated[j]))  # Constraints   }    # Paired item updates with adaptive rates   update_count <- 0   for (person in unique(resp$id)) {     person_idx <- which(resp$id == person)     if (length(person_idx) >= 2) {       for (i in 2:length(person_idx)) {         resp_person <- resp[resp$id == person, ]         n_responses <- nrow(resp_person)         K_beta_adaptive <- 0.1 / (1 + n_responses * 0.05)                  idx_now <- person_idx[i]         idx_prev <- person_idx[i - 1]         item_now <- resp$item[idx_now]         item_prev <- resp$item[idx_prev]         s_now <- resp$resp[idx_now]         s_prev <- resp$resp[idx_prev]         e_now <- E_Sij[idx_now]         e_prev <- E_Sij[idx_prev]         kappa <- 0.5 * (K_beta_adaptive * (s_now - e_now) - K_beta_adaptive * (s_prev - e_prev))         diff_updated[item_now] <- diff_updated[item_now] + kappa         diff_updated[item_prev] <- diff_updated[item_prev] - kappa                  # Apply constraints         diff_updated[item_now] <- max(-4, min(4, diff_updated[item_now]))         diff_updated[item_prev] <- max(-4, min(4, diff_updated[item_prev]))                  update_count <- update_count + 1       }     }   }    cat(\"Prowise item updates triggered:\", update_count, \"\\n\")    out <- list(     theta_est = theta_updated,     diff_est = diff_updated,     resp_cur = resp   )   return(out) }  # Run simulation results <- meow(   select_fun = select_max_info,   update_fun = update_prowise_learn_improved,   data_loader = data_simple_1pl,   data_args = list(N_persons = 100, N_items = 50, data_seed = 123) )  # Analyze results print(head(results$results))"},{"path":"http://klintkanopka.com/meow/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Klint Kanopka. Author, maintainer. Sophia Deng. Author.","code":""},{"path":"http://klintkanopka.com/meow/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kanopka K, Deng S (2025). meow: Unified Framework Computer Adaptive Testing Simulations. R package version 0.1.0, http://klintkanopka.com/meow/.","code":"@Manual{,   title = {meow: Unified Framework for Computer Adaptive Testing Simulations},   author = {Klint Kanopka and Sophia Deng},   year = {2025},   note = {R package version 0.1.0},   url = {http://klintkanopka.com/meow/}, }"},{"path":"http://klintkanopka.com/meow/index.html","id":"meow-","dir":"","previous_headings":"","what":"Unified Framework for Computer Adaptive Testing Simulations","title":"Unified Framework for Computer Adaptive Testing Simulations","text":"meow package conducting simulations computer adaptive testing (CAT). pitch meow framework facilitates reproducible comparisons different combinations data generating processes (DGPs), item selection algorithms, parameter update algorithms. functionalizing components treating modular use core simulation harness produces consistent outputs ggplot2-based visualization tools. goal expose structure component functions user, allowing implement custom DGPs, selection algorithms, update algorithms. Users also encouraged contribute function modules associated research projects, facilitating community interaction.","code":""},{"path":"http://klintkanopka.com/meow/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Unified Framework for Computer Adaptive Testing Simulations","text":"Interested users can install using:","code":"# install.packages(\"remotes\") remotes::install_github(\"klintkanopka/meow\")"},{"path":"http://klintkanopka.com/meow/reference/construct_adj_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructs an item pool adjacency matrix. ‚Äî construct_adj_mat","title":"Constructs an item pool adjacency matrix. ‚Äî construct_adj_mat","text":"item pool N items, NxN matrix. diagonal elements contain number times item exposed. -diagonal elements contain number times pair items exposed respondent. general, function never called directly, instead called within meow() calls. said, exposed user aid testing functions may write.","code":""},{"path":"http://klintkanopka.com/meow/reference/construct_adj_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructs an item pool adjacency matrix. ‚Äî construct_adj_mat","text":"","code":"construct_adj_mat(resp_cur, pers_tru, item_tru)"},{"path":"http://klintkanopka.com/meow/reference/construct_adj_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructs an item pool adjacency matrix. ‚Äî construct_adj_mat","text":"resp_cur long-form dataframe observed item responses. pers_tru dataframe true respondent abilities. item_tru dataframe true item parameters.","code":""},{"path":"http://klintkanopka.com/meow/reference/construct_adj_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructs an item pool adjacency matrix. ‚Äî construct_adj_mat","text":"adjacency matrix type matrix.","code":""},{"path":"http://klintkanopka.com/meow/reference/data_existing.html","id":null,"dir":"Reference","previous_headings":"","what":"Load data from existing files ‚Äî data_existing","title":"Load data from existing files ‚Äî data_existing","text":"data_existing() wrapper three separate calls read.csv() packages output object used meow().","code":""},{"path":"http://klintkanopka.com/meow/reference/data_existing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load data from existing files ‚Äî data_existing","text":"","code":"data_existing(resp_path, pers_path, item_path)"},{"path":"http://klintkanopka.com/meow/reference/data_existing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load data from existing files ‚Äî data_existing","text":"resp_path file path long form .csv file. File three columns, id contains numeric respondent identifier, item contains numeric item identifier, resp contains item response. sure form item response comports parameter update functions choose use. pers_path file path wide form .csv file contains true person parameter values, one person per row. Include person index column, named id. Default column name unidimensional person ability theta item_path file path wide form .csv file contains true item parameter values, one item per row. Include item index column, named item. Default column names difficulty b default column name discrimination ,","code":""},{"path":"http://klintkanopka.com/meow/reference/data_existing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load data from existing files ‚Äî data_existing","text":"list three components: dataframe item response named resp, dataframe true person parameters named pers_tru, dataframe true item parameters named item_tru","code":""},{"path":"http://klintkanopka.com/meow/reference/data_simple_1pl.html","id":null,"dir":"Reference","previous_headings":"","what":"A default data generation function that simulates normally distributed respondent abilities and item difficulties ‚Äî data_simple_1pl","title":"A default data generation function that simulates normally distributed respondent abilities and item difficulties ‚Äî data_simple_1pl","text":"data_simple_1pl() constructs data according simple one parameter logistic IRT model. user may specify number persons, number items, random seed reproducibility. Person abilities item difficulties drawn standard normal.","code":""},{"path":"http://klintkanopka.com/meow/reference/data_simple_1pl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A default data generation function that simulates normally distributed respondent abilities and item difficulties ‚Äî data_simple_1pl","text":"","code":"data_simple_1pl(N_persons = 100, N_items = 50, data_seed = 242424)"},{"path":"http://klintkanopka.com/meow/reference/data_simple_1pl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A default data generation function that simulates normally distributed respondent abilities and item difficulties ‚Äî data_simple_1pl","text":"N_persons Number respondents simulate N_items Number items simulate data_seed random seed generating reproducible data. seed re-initialized end data generation process","code":""},{"path":"http://klintkanopka.com/meow/reference/data_simple_1pl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A default data generation function that simulates normally distributed respondent abilities and item difficulties ‚Äî data_simple_1pl","text":"list three components: dataframe item response named resp, dataframe true person parameters named pers_tru, dataframe true item parameters named item_tru","code":""},{"path":"http://klintkanopka.com/meow/reference/meow.html","id":null,"dir":"Reference","previous_headings":"","what":"Conducts a full CAT simulation. ‚Äî meow","title":"Conducts a full CAT simulation. ‚Äî meow","text":"meow() core function simulation framework exists help users compare efficiency tradeoffs across different item selection algorithms, parameter update algorithms, data generating processes. takes arguments item selection function, parameter update function, data loader function uses carry simulation full CAT administration. Default behavior proceed items administered. Since internal simulation logic checks see additional items administered, early stopping conditions implemented within item selection functions. Internal parameters passed around dataframes maximum flexibility.","code":""},{"path":"http://klintkanopka.com/meow/reference/meow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conducts a full CAT simulation. ‚Äî meow","text":"","code":"meow(   select_fun,   update_fun,   data_loader,   select_args = list(),   update_args = list(),   data_args = list(),   init = NULL,   fix = \"none\" )"},{"path":"http://klintkanopka.com/meow/reference/meow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conducts a full CAT simulation. ‚Äî meow","text":"select_fun function specifies item selection algorithm. update_fun function specifies parameter update algorithm. data_loader function specifies data generating process. select_args named list arguments passed select_fun. update_args named list arguments passed update_fun. data_args named list arguments passed data_loader. init list initialization values estimated person item parameters. Currently accepts named list two entities: pers item, initial estimated values ability difficulty, respectively. Defaults NULL, initializes estimated parameters zero. fix estimated parameters treat fixed. Currently defaults none, accepts pers, item, .`","code":""},{"path":"http://klintkanopka.com/meow/reference/meow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conducts a full CAT simulation. ‚Äî meow","text":"list four named entities, results dataframe one row per iteration simulation. contains one iter iteration number two columns per person item parameter, one associated estimated parameter one bias estimate. Next list item-item adjacency matrices, contained adj_mats. One matrix provided per iteration simulation, edge weights number respondents responded pair items. Finally, true ability difficulty dataframes returned pers_tru item_tru.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_max_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Item selection function based on network distance criterion. ‚Äî select_max_dist","title":"Item selection function based on network distance criterion. ‚Äî select_max_dist","text":"item selection function delivers item farthest network items respondent already answered, edges weighted inverse entry item-item adjacency matrix. Ties broken using maximum information criterion.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_max_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Item selection function based on network distance criterion. ‚Äî select_max_dist","text":"","code":"select_max_dist(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   n_candidates = 1 )"},{"path":"http://klintkanopka.com/meow/reference/select_max_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Item selection function based on network distance criterion. ‚Äî select_max_dist","text":"pers dataframe current respondent ability estimates. item dataframe current item parameter estimates. resp long-form dataframe potential pre-simulated item responses. resp_cur long-form dataframe administered item responses. adj_mat item-item adjacency matrix, entry count individuals respondent item item j. See documentation construct_adj_mat n_candidates parameter allows assembly pool $N$ farthest items, selecting next item according maximum information. Allows users balance exposure patterns away increased network density toward efficient estimation.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_max_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Item selection function based on network distance criterion. ‚Äî select_max_dist","text":"long-form dataframe previously administered item responses new responses iteration appended end.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_max_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Item selection function that delivers the the remaining item with the highest information. ‚Äî select_max_info","title":"Item selection function that delivers the the remaining item with the highest information. ‚Äî select_max_info","text":"Information calculation based upon current parameter estimates 2PL item response function.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_max_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Item selection function that delivers the the remaining item with the highest information. ‚Äî select_max_info","text":"","code":"select_max_info(pers, item, resp, resp_cur = NULL, adj_mat = NULL)"},{"path":"http://klintkanopka.com/meow/reference/select_max_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Item selection function that delivers the the remaining item with the highest information. ‚Äî select_max_info","text":"pers dataframe current respondent ability estimates. item dataframe current item parameter estimates. resp long-form dataframe potential pre-simulated item responses. resp_cur long-form dataframe administered item responses. adj_mat item-item adjacency matrix, entry count individuals respondent item item j. See documentation construct_adj_mat","code":""},{"path":"http://klintkanopka.com/meow/reference/select_max_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Item selection function that delivers the the remaining item with the highest information. ‚Äî select_max_info","text":"long-form dataframe previously administered item responses new responses iteration appended end.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_random.html","id":null,"dir":"Reference","previous_headings":"","what":"Item selection function that delivers an item an item drawn at random from the item bank to each respondent. ‚Äî select_random","title":"Item selection function that delivers an item an item drawn at random from the item bank to each respondent. ‚Äî select_random","text":"respondent next item drawn random remaining items.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_random.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Item selection function that delivers an item an item drawn at random from the item bank to each respondent. ‚Äî select_random","text":"","code":"select_random(   pers,   item,   resp,   resp_cur = NULL,   adj_mat = NULL,   select_seed = NULL )"},{"path":"http://klintkanopka.com/meow/reference/select_random.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Item selection function that delivers an item an item drawn at random from the item bank to each respondent. ‚Äî select_random","text":"pers dataframe current respondent ability estimates. item dataframe current item parameter estimates. resp long-form dataframe potential pre-simulated item responses. resp_cur long-form dataframe administered item responses. adj_mat item-item adjacency matrix, entry count individuals respondent item item j. See documentation construct_adj_mat select_seed random seed used item selection. Cleared time function run.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_random.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Item selection function that delivers an item an item drawn at random from the item bank to each respondent. ‚Äî select_random","text":"long-form dataframe previously administered item responses new responses iteration appended end.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_sequential.html","id":null,"dir":"Reference","previous_headings":"","what":"Item selection function that delivers the next item by item id number, simulating a fixed test form. ‚Äî select_sequential","title":"Item selection function that delivers the next item by item id number, simulating a fixed test form. ‚Äî select_sequential","text":"function just administers next item form, within-person item ordering governed ordering rows resp dataframe.","code":""},{"path":"http://klintkanopka.com/meow/reference/select_sequential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Item selection function that delivers the next item by item id number, simulating a fixed test form. ‚Äî select_sequential","text":"","code":"select_sequential(pers, item, resp, resp_cur = NULL, adj_mat = NULL)"},{"path":"http://klintkanopka.com/meow/reference/select_sequential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Item selection function that delivers the next item by item id number, simulating a fixed test form. ‚Äî select_sequential","text":"pers dataframe current respondent ability estimates. item dataframe current item parameter estimates. resp long-form dataframe potential pre-simulated item responses. resp_cur long-form dataframe administered item responses. adj_mat item-item adjacency matrix, entry count individuals respondent item item j. See documentation construct_adj_mat","code":""},{"path":"http://klintkanopka.com/meow/reference/select_sequential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Item selection function that delivers the next item by item id number, simulating a fixed test form. ‚Äî select_sequential","text":"long-form dataframe previously administered item responses new responses iteration appended end.","code":""},{"path":"http://klintkanopka.com/meow/reference/update_maths_garden.html","id":null,"dir":"Reference","previous_headings":"","what":"Elo-style updates of person and item parameters ‚Äî update_maths_garden","title":"Elo-style updates of person and item parameters ‚Äî update_maths_garden","text":"update function updates person item parameters according approach paper \"Computer adaptive practice Maths ability using new item response model fly ability difficulty estimation\" (Klinkenberg, Straatemeier, van der Maas, 2011). Learning rates tunable using supplied K_theta K_b arguments.","code":""},{"path":"http://klintkanopka.com/meow/reference/update_maths_garden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elo-style updates of person and item parameters ‚Äî update_maths_garden","text":"","code":"update_maths_garden(pers, item, resp, K_theta = 0.1, K_b = 0.1)"},{"path":"http://klintkanopka.com/meow/reference/update_maths_garden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elo-style updates of person and item parameters ‚Äî update_maths_garden","text":"pers dataframe current respondent parameter estimates. item dataframe current item parameter estimates. resp long-form dataframe observed item responses. K_theta User supplied learning rate person ability updates. Defaults 0.1 K_b User supplied learning rate item difficulty updates. Defaults 0.1","code":""},{"path":"http://klintkanopka.com/meow/reference/update_maths_garden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elo-style updates of person and item parameters ‚Äî update_maths_garden","text":"list three objects, two updated function input: pers dataframe updated respondent parameter estimates, item dataframe updated item parameter estimates. resp_cur dataframe observed item responses.","code":""},{"path":"http://klintkanopka.com/meow/reference/update_prowise_learn.html","id":null,"dir":"Reference","previous_headings":"","what":"Elo-style updates of person and item parameters ‚Äî update_prowise_learn","title":"Elo-style updates of person and item parameters ‚Äî update_prowise_learn","text":"update function updates person item parameters according approach paper \"Psychometrics Elo-based large-scale online learning system\" (Vermeiren, et al. 2025)","code":""},{"path":"http://klintkanopka.com/meow/reference/update_prowise_learn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elo-style updates of person and item parameters ‚Äî update_prowise_learn","text":"","code":"update_prowise_learn(pers, item, resp, K_theta = 0.1, K_b = 0.1)"},{"path":"http://klintkanopka.com/meow/reference/update_prowise_learn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elo-style updates of person and item parameters ‚Äî update_prowise_learn","text":"pers dataframe current respondent parameter estimates. item dataframe current item parameter estimates. resp long-form dataframe observed item responses. K_theta User supplied learning rate person ability updates. Defaults 0.1 K_b User supplied learning rate item difficulty updates. Defaults 0.1","code":""},{"path":"http://klintkanopka.com/meow/reference/update_prowise_learn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elo-style updates of person and item parameters ‚Äî update_prowise_learn","text":"list three objects, two updated function input: pers dataframe updated respondent parameter estimates, item dataframe updated item parameter estimates. resp_cur dataframe observed item responses.","code":""},{"path":"http://klintkanopka.com/meow/reference/update_theta_mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Updated person parameters based on MLE estimates ‚Äî update_theta_mle","title":"Updated person parameters based on MLE estimates ‚Äî update_theta_mle","text":"update function treats item parameters fixed known, updating person ability estimates iteration according maximum likelihood estimate based upon 2PL item response function.","code":""},{"path":"http://klintkanopka.com/meow/reference/update_theta_mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updated person parameters based on MLE estimates ‚Äî update_theta_mle","text":"","code":"update_theta_mle(pers, item, resp)"},{"path":"http://klintkanopka.com/meow/reference/update_theta_mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updated person parameters based on MLE estimates ‚Äî update_theta_mle","text":"pers dataframe current respondent parameter estimates. item dataframe item parameter values. resp long-form dataframe observed item responses.","code":""},{"path":"http://klintkanopka.com/meow/reference/update_theta_mle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updated person parameters based on MLE estimates ‚Äî update_theta_mle","text":"list three objects, one updated function input: pers dataframe updated respondent parameter estimates, item dataframe item parameter values. resp_cur dataframe observed item responses.","code":""}]
